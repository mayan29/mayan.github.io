<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="mayan`s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="mayan`s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mayan`s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>mayan`s blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mayan`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/23/【读书笔记】《第一行代码 Android 第2版》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mayan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mayan`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/23/【读书笔记】《第一行代码 Android 第2版》/" itemprop="url">【读书笔记】《第一行代码 Android 第2版》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-23T00:05:34+08:00">
                2018-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/23/【读书笔记】《第一行代码 Android 第2版》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/23/【读书笔记】《第一行代码 Android 第2版》/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：郭霖</p>
<p>出版日期：2016-12-1</p>
<p>豆瓣地址：<a href="https://book.douban.com/subject/26915433/" target="_blank" rel="noopener">https://book.douban.com/subject/26915433/</a></p>
<p>源代码地址：<a href="https://github.com/guolindev/booksource/" target="_blank" rel="noopener">https://github.com/guolindev/booksource/</a></p>
<p>Android Studio 下载地址：<a href="https://developer.android.google.cn/studio/" target="_blank" rel="noopener">https://developer.android.google.cn/studio/</a></p>
</blockquote>
<h2 id="Android-简介"><a href="#Android-简介" class="headerlink" title="Android 简介"></a>Android 简介</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>Android 大致可以分为四层架构：Linux 内核层、系统运行库层、应用框架层、应用层。</p>
<ul>
<li><p>Linux 内核层：这一层为 Android 设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、WiFi 驱动、电源管理等。</p>
</li>
<li><p>系统运行库层：这一层通过一些库提供了主要的特性支持，如 SQLite 库提供了数据库、OpenGL|ES 库提供了 3D 绘图、Webkit 库提供了浏览器内核等。同样在这一层还有 Android 运行时库提供了一些核心库，允许开发者使用 Java 来编写 Android 应用、Dalvik 虚拟机针对手机内存和 CPU 性能有限等情况做了优化处理。</p>
</li>
<li><p>应用框架层：这一层主要提供了构建应用程序时可能用到的各种 API。</p>
</li>
<li><p>应用层：所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序。</p>
</li>
</ul>
<h3 id="开发组件"><a href="#开发组件" class="headerlink" title="开发组件"></a>开发组件</h3><p>Android 系统四大组件分别是活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver）、内容提供器（Content Provider）。</p>
<ul>
<li><p>活动：应用程序的门面，凡是在应用中看得到的东西，都是放在活动中的。</p>
</li>
<li><p>服务：无法看到它，但它会一直在后台默默地运行，即时用户退出了应用，服务仍然可以继续运行。</p>
</li>
<li><p>广播接收器：允许应用程序接收或者发送的广播消息，比如电话、短信。</p>
</li>
<li><p>内容提供器：提供应用程序之间数据共享，比如读取系统电话簿。</p>
</li>
</ul>
<h2 id="运行-Hello-World"><a href="#运行-Hello-World" class="headerlink" title="运行 Hello World"></a>运行 Hello World</h2><h3 id="设置夜神模拟器"><a href="#设置夜神模拟器" class="headerlink" title="设置夜神模拟器"></a>设置夜神模拟器</h3><ol>
<li>运行 Android Studio 和夜神模拟器</li>
<li>打开终端，进入夜神模拟器的安装目录下，并执行连接命令</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Applications/Nox\ App\ Player.app/Contents/MacOS`</span><br><span class="line">$ adb connect <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">62001</span></span><br></pre></td></tr></table></figure>
<h3 id="设置模拟器可能出现的问题"><a href="#设置模拟器可能出现的问题" class="headerlink" title="设置模拟器可能出现的问题"></a>设置模拟器可能出现的问题</h3><h4 id="1-adb-command-not-found-问题"><a href="#1-adb-command-not-found-问题" class="headerlink" title="1. adb: command not found 问题"></a>1. <code>adb: command not found</code> 问题</h4><ul>
<li>打开终端，输入 <code>cd ~/</code> 进入当前用户的 home 目录；</li>
<li>输入 <code>touch .bash_profile</code> 如果没有 .bash_profile 文件，则创建一个该文件；</li>
<li>输入 <code>open .bash_profile</code> 打开该文件，如果是第一次配置环境，那么文本编辑框为空白；</li>
<li>在打开的文本编辑器中写入如下代码，其中 ANDROID_HOME 的 sdk 路径可以打开 preference 中搜索 sdk 来查看；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> ANDROID_HOME=/Users/mayan/Library/Android/sdk</span><br><span class="line"><span class="keyword">export</span> PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/tools</span><br><span class="line"><span class="keyword">export</span> PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-tools</span><br></pre></td></tr></table></figure>
<ul>
<li>在终端中输入 <code>source .bash_profile</code> 使改动生效；</li>
<li>输入 <code>adb</code> 验证是否完成配置，如果不显示 <code>adb: command not found</code> 则说明配置完成。</li>
</ul>
<h4 id="2-点击运行按钮后找不到夜神模拟器"><a href="#2-点击运行按钮后找不到夜神模拟器" class="headerlink" title="2. 点击运行按钮后找不到夜神模拟器"></a>2. 点击运行按钮后找不到夜神模拟器</h4><p>重启 Android Studio 和夜神模拟器。</p>
<h3 id="分析项目结构"><a href="#分析项目结构" class="headerlink" title="分析项目结构"></a>分析项目结构</h3><p>点击项目目录结构上面的 Android 区域切换成 Project 模式，这就是项目真实的目录结构了。</p>
<h4 id="1-gradle-和-idea"><a href="#1-gradle-和-idea" class="headerlink" title="1. .gradle 和 .idea"></a>1. .gradle 和 .idea</h4><p>这两个目录下放置的都是 Android Studio 自动生成的一些文件，无需关心，也不要手动编辑。</p>
<h4 id="2-app"><a href="#2-app" class="headerlink" title="2. app"></a>2. app</h4><p>项目中的代码、资源等内容几乎都是放置在这个目录下的，我们后面的开发工作也基本都是在这个目录下进行的，下面会详细展开讲解。</p>
<h4 id="3-gradle"><a href="#3-gradle" class="headerlink" title="3. gradle"></a>3. gradle</h4><p>这个目录下包含了 gradle wrapper 的配置文件，使用 gradle wrapper 的方式不需要提前将 gradle 下载好，而是会自动根据本地的缓存情况决定是否需要联网下载 gradle。Android Studio 默认没有启用 gradle wrapper 的方式，如果需要打开，可以点击 Android Studio 导航栏 -&gt; File -&gt; Settings -&gt; Build,Execution,Deployment -&gt; Gradle 进行配置更改。</p>
<h4 id="4-build-gradle"><a href="#4-build-gradle" class="headerlink" title="4. build.gradle"></a>4. build.gradle</h4><p>这是项目全局的 gradle 构建脚本，通常这个文件中的内容是不需要修改的。</p>
<h4 id="5-gradle-properties"><a href="#5-gradle-properties" class="headerlink" title="5. gradle.properties"></a>5. gradle.properties</h4><p>这个文件是全局的 gradle 配置文件，在这里配置的属性将会影响到项目中所有的 gradle 编译脚本。</p>
<h4 id="6-gradlew-和-gradlew-bat"><a href="#6-gradlew-和-gradlew-bat" class="headerlink" title="6. gradlew 和 gradlew.bat"></a>6. gradlew 和 gradlew.bat</h4><p>这两个文件是用来在命令行界面中执行 gradle 命令的，其中 gradlew 是在 Linux 或 Mac 系统中使用的，gradlew.bat 是在 Windows 系统中使用的。</p>
<h4 id="7-HelloWorld-iml"><a href="#7-HelloWorld-iml" class="headerlink" title="7. HelloWorld.iml"></a>7. HelloWorld.iml</h4><p>iml 文件是所有 IntelliJ IDEA 项目都会自动生成的一个文件（Android Studio 是基于 IntelliJ IDEA 开发的），用于标识这是一个 IntelliJ IDEA 项目，我们不需要修改这个文件中任何内容。</p>
<h4 id="8-local-properties"><a href="#8-local-properties" class="headerlink" title="8. local.properties"></a>8. local.properties</h4><p>这个文件用于指定本机中的 Android SDK 路径，通常内容都是自动生成的，我们并不需要修改，除非本机中的 Android SDK 位置发生了变化。</p>
<h4 id="9-settings-gradle"><a href="#9-settings-gradle" class="headerlink" title="9. settings.gradle"></a>9. settings.gradle</h4><p>这个文件用于指定项目中所有引入的模块，由于 HelloWorld 项目中就只有一个 app 模块，因此该文件中也就只引入了 app 这一个模块。通常模块的引入都是自动完成的，需要我们手动去修改这个文件的场景可能比较少。</p>
<h3 id="分析-app-目录下项目结构"><a href="#分析-app-目录下项目结构" class="headerlink" title="分析 app 目录下项目结构"></a>分析 app 目录下项目结构</h3><h4 id="1-build"><a href="#1-build" class="headerlink" title="1. build"></a>1. build</h4><p>这个目录和外层的 build 目录类似，主要也是包含了一些在编译时自动生成的文件，不过它里面的内容会更多更杂，我们不需要过多关心。</p>
<h4 id="2-libs"><a href="#2-libs" class="headerlink" title="2. libs"></a>2. libs</h4><p>如果你的项目中使用了第三方 jar 包，就需要把这些 jar 包都放在 libs 目录下，并且会被自动添加到构建路径里去。</p>
<p>P19</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/19/【iOS】每日一道面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mayan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mayan`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/19/【iOS】每日一道面试题/" itemprop="url">【iOS】每日一道面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T10:21:55+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/19/【iOS】每日一道面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/06/19/【iOS】每日一道面试题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>坚持每日记录一道面试题，持续更新。★ 为超级简单题目，★★ 为简单题目，以此类推，满级 ★★★★★ 五星。</p>
<h2 id="C-Objective-C"><a href="#C-Objective-C" class="headerlink" title="C / Objective-C"></a>C / Objective-C</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p><strong>题目：把 “<a href="http://www.zhidao.baidu.com&quot;" target="_blank" rel="noopener">www.zhidao.baidu.com&quot;</a> 字符串改成 “com/baidu/zhidao/www”。</strong><br><strong>星级：★</strong>  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"www.zhidao.baidu.com"</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *tmpArray = [str componentsSeparatedByString:<span class="string">@"."</span>];</span><br><span class="line">tmpArray = [[tmpArray reverseObjectEnumerator] allObjects];  <span class="comment">// 数组倒叙排列</span></span><br><span class="line"><span class="built_in">NSString</span> *resultStr = [tmpArray componentsJoinedByString:<span class="string">@"/"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, resultStr);</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com/baidu/zhidao/www</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实这道题一点难点都没有，唯一需要注意的是要熟记这三个方法的方法名。</p>
<p>components - n. 组件<br>separated - adj. 分离的<br>reverse - v. 反转，颠倒<br>enumerator - n. 枚举器</p>
</blockquote>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p><strong>题目：不用临时变量怎么实现 swap(a, b) ？</strong><br><strong>星级：★</strong>  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"a = %d, b = %d"</span>, a, b);  </span><br><span class="line"></span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"a = %d, b = %d"</span>, a, b);</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>, b = <span class="number">20</span></span><br><span class="line">a = <span class="number">20</span>, b = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>用加法或者异或都可以，我比较偏好于异或，因为如果使用加法，两个数值太大的情况下，容易超出 int 范围。</p>
</blockquote>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><strong>题目：下面这段代码的输出结果是？</strong><br><strong>星级：★★</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d, %d"</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>, <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>a 是指向数组开头元素的指针，a + 1 就是指向下一个元素的指针，所以星号求值以后是 2。&amp;a 相当于是数组的指针，&amp;a + 1 是数组后面一个数组的指针，然后转换成 int * 类型是 5 这个数字后面的一个数字的指针。再减一就是指向 5 的指针，所以星号求值以后是 5。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>进程和线程的区别</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><p>异步和同步，串行，并发，并行的区别</p>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h3><p>多并发任务，仅多线程能加快速度么（不能，会变慢，有线程切换的开销）</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>多个线程之间可以共享那些数据</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>进程之间如何通信</p>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p><strong>题目：使用 GCD 如何实现这个需求：A、B、C 三个任务并发，完成后执行任务 D。</strong><br><strong>星级：★★</strong></p>
<p>可以用两种方法实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCD Group</span></span><br><span class="line"></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 A 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 B 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 C 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 D 任务"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GCD Barrier</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mayan29.gcd"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 A 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 B 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 C 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"可以做一些其他操作"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 D 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="meta">### 7</span></span><br><span class="line"></span><br><span class="line">__题目：<span class="built_in">NSOperation</span> 和 GCD 的区别？__</span><br><span class="line">__星级：★★__</span><br><span class="line"></span><br><span class="line">- GCD 是基于 C 语言的 API，而 <span class="built_in">NSOperation</span> 及相关对象是 Objective-C 对象。在 GCD 中，在队列中执行的是由 block 构成的任务，这是一个轻量级的数据结构，而 <span class="built_in">NSOperation</span> 作为一个对象，为我们提供更多的选择（取消任务、依赖、优先级、继承、键值对观察）；</span><br><span class="line">- <span class="built_in">NSOperationQueue</span> 可以取消尚未执行的任务（已经开始的任务就无法阻止了），而 GCD 没法停止已经加入 queue 的 block（其实可以，但需要许多复杂的代码）；</span><br><span class="line">- <span class="built_in">NSOperation</span> 能够方便地设置依赖关系，我们可以让一个 Operation 依赖于另一个Operation，这样的话尽管两个 Operation 处于同一个并行队列中，但前者会直到后者执行完毕后再执行；</span><br><span class="line">- 在 <span class="built_in">NSOperation</span> 中，我们能够设置 <span class="built_in">NSOperation</span> 的 priority 优先级，能够使同一个并行队列中的任务区分先后地执行，而在 GCD 中我们只能区分不同任务队列的优先级，如果要区分 block 任务的优先级，也需要大量的复杂代码；</span><br><span class="line">- 我们能够对 <span class="built_in">NSOperation</span> 进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将 block 任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。</span><br><span class="line">- 我们能将 KVO 应用在 <span class="built_in">NSOperation</span> 中，可以监听一个 Operation 是否完成或者取消，这样能比 GCD 更加有效的掌控我们执行的后台任务；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">## UIKit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">## 操作系统与编译</span></span><br><span class="line"></span><br><span class="line"><span class="meta">### 1</span></span><br><span class="line"></span><br><span class="line">__题目：OC 中 load 和 initialize 方法有何异同？__</span><br><span class="line">__星级：★★__</span><br><span class="line"></span><br><span class="line">相同点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> load 和 initialize 方法都会在实例化对象之前调用，main 函数之前调用 load，之后调用 initialize；</span><br><span class="line"><span class="number">2.</span> load 和 initialize 方法都只会调用一次；</span><br><span class="line"><span class="number">3.</span> load 和 initialize 方法都会被自动调用，不能手动调用它们；</span><br><span class="line"><span class="number">4.</span> load 和 initialize 方法调用，会从父到子依次实现父类们的 load 和 initialize 方法；</span><br><span class="line"><span class="number">5.</span> load 和 initialize 方法内部为了保证线程安全都使用了锁，实现时要保持逻辑简单，避免阻塞线程；</span><br><span class="line"></span><br><span class="line">不同点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> load 方法通常用来进行 Method Swizzle，initialize 方法通常用于初始化全局变量或者静态变量。</span><br><span class="line"><span class="number">2.</span> load 方法在类被程序装载时调用，与这个类是否被用到无关，initialize 方法是在类或者它的子类接收第一条消息前被调用。如果该类一直没有被用到，它的 initialize 方法也不会调用。</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> load 方法调用顺序永远都是：parent &gt; child &gt; child+extend ；</span><br><span class="line"><span class="number">2.</span> 当有 child+extend 存在的时候，child+extend 中的 initialize 方法会覆盖 child 中的 initialize 方法。</span><br><span class="line"></span><br><span class="line">具体分析和实例参考：[细说 OC 中的 load 和 initialize 方法](https:<span class="comment">//bestswifter.com/load-and-initialize/)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">### 2</span></span><br><span class="line"></span><br><span class="line">__题目：如果页面 A 跳转到 页面 B，A 的 viewDidDisappear 方法和 B 的 viewDidAppear 方法哪个先调用？__</span><br><span class="line">__星级：★__</span><br><span class="line"></span><br><span class="line">注意这里分两种情况：</span><br><span class="line"></span><br><span class="line">A push B</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="number">1.</span> 调用 A 的 viewWillDisappear 方法</span><br><span class="line"><span class="number">2.</span> 调用 B 的 viewWillAppear 方法</span><br><span class="line"><span class="number">3.</span> 调用 A 的 viewDidDisappear 方法</span><br><span class="line"><span class="number">4.</span> 调用 B 的 viewDidDAppear 方法</span><br></pre></td></tr></table></figure>
<p>A present B</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 调用 A 的 viewWillDisappear 方法</span><br><span class="line"><span class="number">2.</span> 调用 C 的 viewWillAppear 方法</span><br><span class="line"><span class="number">3.</span> 调用 C 的 viewDidAppear 方法</span><br><span class="line"><span class="number">4.</span> 调用 A 的 viewDidDisappear 方法</span><br></pre></td></tr></table></figure>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h2 id="待总结题目"><a href="#待总结题目" class="headerlink" title="待总结题目"></a>待总结题目</h2><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ol>
<li>说说你对 block 的理解。 —— 三种 block，栈上的 block 在 ARC 下会自动复制到堆上，block 的属性修饰符是 copy，循环引用的原理和解决方案。</li>
<li>block 为什么会有循环引用</li>
<li>说说你对 runtime 的理解。 —— 主要是方法调用时如何查找缓存，如何找到方法，找不到方法时怎么转发，对象的内存布局。</li>
<li>说说你对 MVC、MVVM 和 RAC 的理解。 —— MVC 的 C 太臃肿，可以和 V 合并，变成 MVVM 中的 V，而 VM 用来将 M 转化成 V 能用的数据。RAC 数据的双向绑定怎么做，bind 函数了解过么。</li>
<li>MVC 具有什么样的优势，各个模块之间怎么通信，比如点击 Button 后 怎么通知 Model？</li>
<li>说说 UITableView 的调优。 —— 一方面是通过 instruments 检查影响性能的地方，另一方面是估算高度并在 runloop 空闲时缓存。</li>
<li>谈谈你对 ARC 的理解。 —— ARC 是编译器完成的，依靠引用计数，谈谈几个属性修饰符的内存管理策略，什么情况下会内存泄露。</li>
<li>野指针是什么，iOS 开发中什么情况下会有野指针？ —— 野指针是不为 nil，但是指向已经被释放的内存的指针。</li>
<li>介绍自己用过哪些开源库。 —— Masonry 和 SnapKit，AFNetWorking，MKNetworkKit，Alamofire，Mantle，SDWebImage</li>
<li>SDWebImage 下载了图片后为什么要解码？ —— 要把 png 文件建立一个内存映射。</li>
<li>两个无限长度链表（也就是可能有环） 判断有没有交点</li>
<li>KVO、Notification、delegate 各自的优缺点，效率还有使用场景</li>
<li>如何手动通知 KVO</li>
<li>Objective-C 中的 copy 方法</li>
<li>runtime 中，SEL 和 IMP 的区别</li>
<li>autoreleasepool 的使用场景和原理</li>
<li>RunLoop 的实现原理和数据结构，什么时候会用到</li>
<li>CoreData 的使用，如何处理多线程问题</li>
<li>如何设计图片缓存？</li>
<li>有没有自己设计过网络控件？</li>
<li>怎么判断某个 cell 是否显示在屏幕上</li>
<li>进程和线程的区别</li>
<li>TCP 与 UDP 区别</li>
<li>TCP 流量控制</li>
<li>数组和链表的区别</li>
<li>UIView 生命周期</li>
<li>ARC 的本质</li>
<li>RunLoop 的基本概念，它是怎么休眠的？</li>
<li>Autoreleasepool 什么时候释放，在什么场景下使用？</li>
<li>如何找到字符串中第一个不重复的字符</li>
<li>哈希表如何处理冲突</li>
</ol>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>算法主要分为以下几个部分：字符串、数组与查找、链表、树以及其他基础问题。</p>
<p>再详细总结一下，比如递归、动态规划、BFS/DFS、双指针、二分搜索等。或者是直接考察数据结构的使用，如：哈希、栈和队列、链表等。</p>
<p>将阅读《剑指 Offer》列入今年的学习计划中。</p>
<p>列出的一些经典题目，在“【】”中标记了我对此题类型的分类，如果加星号表示此题在实际面试中出现过：</p>
<p>字符串</p>
<ul>
<li>【3】最长回文子串（<a href="https://leetcode.com/problems/longest-palindromic-substring/）" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-substring/）</a></li>
<li>【3】最长无重复子串（<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/）" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/）</a></li>
<li>【1*】字符串转数字（<a href="https://leetcode.com/problems/string-to-integer-atoi/）" target="_blank" rel="noopener">https://leetcode.com/problems/string-to-integer-atoi/）</a></li>
<li>【4】KMP 算法</li>
<li>【2】字符串全排列（<a href="http://blog.csdn.net/morewindows/article/details/7370155）" target="_blank" rel="noopener">http://blog.csdn.net/morewindows/article/details/7370155）</a></li>
<li>【2*】翻转字符串（<a href="https://leetcode.com/problems/reverse-words-in-a-string/）" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-words-in-a-string/）</a></li>
</ul>
<p>动态规划</p>
<ul>
<li>【2】背包问题（<a href="http://baike.baidu.com/link?url=rhsiQhWz0xoYrm265bZQfow1IePC8X_MVUUlw9V9Ymu9g4Cwoqu-fjZIGOJZqe_V4ONMJlXug1IN0Cj_g0O3Ya）" target="_blank" rel="noopener">http://baike.baidu.com/link?url=rhsiQhWz0xoYrm265bZQfow1IePC8X_MVUUlw9V9Ymu9g4Cwoqu-fjZIGOJZqe_V4ONMJlXug1IN0Cj_g0O3Ya）</a></li>
<li>【3】连续子数组的最大和（<a href="https://leetcode.com/problems/maximum-subarray/）" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/）</a></li>
<li>【4】实现简单的正则表达式匹配（<a href="https://leetcode.com/problems/regular-expression-matching/）" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/）</a></li>
</ul>
<p>数组</p>
<ul>
<li>【3】求两个等长、有序数组的中位数（二分法）</li>
<li>【4】求两个不等长、有序数组的中位数（<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/）" target="_blank" rel="noopener">https://leetcode.com/problems/median-of-two-sorted-arrays/）</a></li>
<li>【3】旋转数组求最小值（二分法）（<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/）" target="_blank" rel="noopener">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/）</a></li>
<li>【3】旋转数组求查找某个值是否存在（二分法）（<a href="https://leetcode.com/problems/search-in-rotated-sorted-array/）" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array/）</a></li>
<li>【4*】每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指 offer 第 3 题）</li>
<li>【3*】数组中出现次数超过一半的数字（<a href="https://bestswifter.com/arrayoccurmorethanhalf/）" target="_blank" rel="noopener">https://bestswifter.com/arrayoccurmorethanhalf/）</a></li>
<li>【3*】第 k 大的数（拓展：最大的 k 个数）（<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/）" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/）</a></li>
<li>【3*】有序数组中某个数字出现的次数（提示：利用二分搜索）</li>
</ul>
<p>链表</p>
<ul>
<li>【2】反转链表（使用递归和迭代两种解法，了解头插法）（<a href="https://leetcode.com/problems/reverse-linked-list/）" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/）</a></li>
<li>【3】删除链表的当前节点（<a href="https://leetcode.com/problems/delete-node-in-a-linked-list/）" target="_blank" rel="noopener">https://leetcode.com/problems/delete-node-in-a-linked-list/）</a></li>
<li>【3】删除倒数第 k 个节点（<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/）" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/）</a></li>
<li>【1】两个有序链表合并（<a href="https://leetcode.com/problems/merge-two-sorted-lists/）" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/）</a></li>
<li>【4】复杂链表的复制（<a href="https://leetcode.com/problems/copy-list-with-random-pointer/）" target="_blank" rel="noopener">https://leetcode.com/problems/copy-list-with-random-pointer/）</a></li>
<li>【2*】判断链表是否有环（<a href="https://leetcode.com/problems/linked-list-cycle-ii/）" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/）</a></li>
<li>【3*】两个链表的第一个公共节点（提示：考虑链表有环的情况）（<a href="http://blog.csdn.net/zzran/article/details/7984870）" target="_blank" rel="noopener">http://blog.csdn.net/zzran/article/details/7984870）</a></li>
<li>【3】删除链表中重复节点（<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/）" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-list/）</a></li>
</ul>
<p>树</p>
<ul>
<li>【3】根据中序和后序遍历结果重建二叉树（<a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/）" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/）</a></li>
<li>【3】根据中序和前序遍历结果重建二叉树（<a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/）" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/）</a></li>
<li>【2】翻转二叉树（<a href="https://leetcode.com/problems/invert-binary-tree/）" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/）</a></li>
<li>【2】从上往下打印二叉树 (BFS 的思想)（<a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/）" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal-ii/）</a></li>
<li>【3】判断某个数组是不是二叉树的后序遍历结果 (剑指 offer 第 24 题)</li>
<li>【3】二叉树中和为某个值的路径（<a href="https://leetcode.com/problems/path-sum-ii/）" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/）</a></li>
<li>【3*】二叉树中某个节点的下一个节点 (强烈推荐准备一下，剑指 offer 第 58 题)</li>
</ul>
<p>栈</p>
<ul>
<li>【2】用两个栈实现队列（<a href="https://leetcode.com/problems/implement-queue-using-stacks/）" target="_blank" rel="noopener">https://leetcode.com/problems/implement-queue-using-stacks/）</a></li>
<li>【2】用两个队列实现栈（<a href="https://leetcode.com/problems/implement-stack-using-queues/）" target="_blank" rel="noopener">https://leetcode.com/problems/implement-stack-using-queues/）</a></li>
<li>【2】实现一个栈，可以用常数级时间找出栈中的最小值（<a href="https://leetcode.com/problems/min-stack/）" target="_blank" rel="noopener">https://leetcode.com/problems/min-stack/）</a></li>
<li>【3】判断栈的压栈、弹栈序列是否合法（剑指offer 第 22 题）</li>
</ul>
<p>排序</p>
<p>了解以下排序的时间、空间复杂度，是否稳定，实现原理</p>
<ul>
<li>归并排序、拓展：求数组中的逆序对个数（<a href="http://baike.baidu.com/link?url=awQj_m-d5Lf_g5TglfU3uN55-0Dt2SmFv3IZx6-Ia86dOyyBoxkJhDyc2oFAzlUXFIXhs2dGehbHAHDqr1DuAK）" target="_blank" rel="noopener">http://baike.baidu.com/link?url=awQj_m-d5Lf_g5TglfU3uN55-0Dt2SmFv3IZx6-Ia86dOyyBoxkJhDyc2oFAzlUXFIXhs2dGehbHAHDqr1DuAK）</a></li>
<li>快速排序 重点：partion 函数的实现（<a href="http://baike.baidu.com/link?url=_sdhFCTSDKNM6wA5OCgqHTJc9kLWjiQBPLzO9-Cw_bYh4vZ7ofkBqySVw-MQDsJfOO9g9SJb2OCuL3yAmHIPWvv_sSPOsf-JZfKOU8QV3HrhInkkfGJ6j5Li4u3nWwiZkQlOUlGEZI-gLIyObuEM7bqwZPR8gLyVEiqutVr8pIDa6gF7cB8eixeQyur2yUt7）" target="_blank" rel="noopener">http://baike.baidu.com/link?url=_sdhFCTSDKNM6wA5OCgqHTJc9kLWjiQBPLzO9-Cw_bYh4vZ7ofkBqySVw-MQDsJfOO9g9SJb2OCuL3yAmHIPWvv_sSPOsf-JZfKOU8QV3HrhInkkfGJ6j5Li4u3nWwiZkQlOUlGEZI-gLIyObuEM7bqwZPR8gLyVEiqutVr8pIDa6gF7cB8eixeQyur2yUt7）</a></li>
<li>堆排序（<a href="http://baike.baidu.com/link?url=eioUPqfLTP0mqIOIuJdH0tp9m3ihgtx2rjcFMDpKhNXcjRidBGuk-XuQtM2Zl0z6J43yKq8VTDfFRzCsN4zj3_）" target="_blank" rel="noopener">http://baike.baidu.com/link?url=eioUPqfLTP0mqIOIuJdH0tp9m3ihgtx2rjcFMDpKhNXcjRidBGuk-XuQtM2Zl0z6J43yKq8VTDfFRzCsN4zj3_）</a></li>
<li>数组元素值域已知时，考虑 基数排序 和 桶排序（<a href="http://baike.baidu.com/view/1170573.htm）（http://baike.baidu.com/view/1784217.htm）" target="_blank" rel="noopener">http://baike.baidu.com/view/1170573.htm）（http://baike.baidu.com/view/1784217.htm）</a></li>
</ul>
<p>位运算</p>
<ul>
<li>【2】给一个十进制数字，求它的二进制表示中，有多少个 1 (n &amp;= n - 1)（<a href="https://leetcode.com/problems/number-of-1-bits/）" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-1-bits/）</a></li>
<li>【3】给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数（<a href="https://leetcode.com/problems/single-number/）" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/）</a></li>
<li>【4】给一个数组，所有数字都出现了三次，只有一个出现了一次，找出这个数（<a href="https://leetcode.com/problems/single-number-ii/）" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-ii/）</a></li>
<li>【3】给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数（<a href="https://leetcode.com/problems/single-number-iii/）" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-iii/）</a></li>
</ul>
<h3 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h3><p>根据不同的面试岗位，侧重点略有不同。对 iOS 和 Android 开发者来说，HTTP 考的略少，以 TCP 和 UDP 为主。其实 UDP 基本上只会考察和 TCP 的区别。</p>
<p>当然还有一些常见的基础问题，比如 Cookie 和 Session 的考察，POST 和 GET 的考察，HTTPS 的简单了解等。这些问题在我的博客中都有简单的总结。</p>
<ul>
<li>【博客】我的六篇总结————不到一周（<a href="http://www.jianshu.com/notebooks/3276500/latest）" target="_blank" rel="noopener">http://www.jianshu.com/notebooks/3276500/latest）</a></li>
<li>【书】图解 TCP/IP————半个月（<a href="http://item.jd.com/11253710.html）" target="_blank" rel="noopener">http://item.jd.com/11253710.html）</a></li>
<li>【书】TCP/IP 详解————没读过，感觉至少需要一个月（<a href="http://item.jd.com/11182320.html）" target="_blank" rel="noopener">http://item.jd.com/11182320.html）</a></li>
<li>【书】TCP/IP 协议簇————没读过，感觉至少需要一个月（<a href="http://item.jd.com/10485475.html）" target="_blank" rel="noopener">http://item.jd.com/10485475.html）</a></li>
</ul>
<p>光读书是没有用的，一问到实际问题很容易懵逼，以下是我总结的一些问题：</p>
<ul>
<li>简介 TCP 和 UDP 区别，他们位于哪一层？</li>
<li>路由器和交换机的工作原理大概是什么，他们分别用到什么协议，位于哪一层？</li>
<li>描述TCP 协议三次握手，四次释放的过程。</li>
<li>TCP 协议是如何进行流量控制，拥塞控制的？</li>
<li>为什么建立连接时是三次握手，两次行不行？如果第三次握手失败了怎么处理</li>
<li>关闭连接时，第四次握手失败怎么处理？</li>
<li>你怎么理解分层和协议？</li>
<li>HTTP 请求中的 GET 和 POST 的区别，Session 和 Cookie 的区别。（<a href="https://bestswifter.com/bat-interview/(http://www.w3school.com.cn/tags/html_ref_httpmethods.asp)）" target="_blank" rel="noopener">https://bestswifter.com/bat-interview/(http://www.w3school.com.cn/tags/html_ref_httpmethods.asp)）</a></li>
<li>谈谈你对 HTTP 1.1，2.0 和 HTTPS 的理解。</li>
</ul>
<h3 id="操作系统与编译"><a href="#操作系统与编译" class="headerlink" title="操作系统与编译"></a>操作系统与编译</h3><p>我被问到的操作系统问题很少，所以仅仅总结了一些自认为比较重要的问题。关于这一部分的知识，推荐阅读《程序员的自我修养》，如果时间有限，你可以阅读我的《程序员的自我修养读书笔记》（<a href="https://bestswifter.com/cheng-xu-yuan-de-zi-wo-xiu-yang-du-shu-bi-ji/），并思考这些问题：" target="_blank" rel="noopener">https://bestswifter.com/cheng-xu-yuan-de-zi-wo-xiu-yang-du-shu-bi-ji/），并思考这些问题：</a></p>
<ul>
<li>源代码是怎么变成可执行文件的，每一步的作用是什么？（预编译，词法分析，语法分析，语义分析，中间语言生成目标代码生成，汇编，链接）</li>
<li>应用层、API、运行库、系统调用、操作系统内核之间的关系是什么？</li>
<li>虚拟内存空间是什么，为什么要有虚拟内存空间。</li>
<li>静态链接和动态链接分别表示什么，大概是怎么实现的？</li>
<li>可执行文件的结构如何？（分为哪些段）</li>
<li>它是怎么装载进内存的，为什么要分段，分页，页错误是什么？</li>
<li>进程的内存格局是怎样的？（堆、栈、全局/静态区，代码区，常量区）</li>
<li>堆和栈的区别，函数调用和栈的关系</li>
<li>介绍几种锁，他们的用途和区别</li>
</ul>
<p>关于多线程相关的，推荐阅读这篇文章的前面一小部分——《iOS多线程编程——GCD与NSOperation总结》（<a href="https://bestswifter.com/multithreadconclusion/）" target="_blank" rel="noopener">https://bestswifter.com/multithreadconclusion/）</a></p>
<p>关于操作系统和编译方面的文章，除了读原书和我的读书笔记外，还可以参考这篇文章——《修改一个数字破解Mac上的应用》（<a href="https://bestswifter.com/app-crack/）" target="_blank" rel="noopener">https://bestswifter.com/app-crack/）</a></p>
<h3 id="OC"><a href="#OC" class="headerlink" title="OC"></a>OC</h3><p>两本神书一边阅读以下总结性的文章，重要性不分先后：</p>
<ul>
<li>检测内存泄露（<a href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/?from=singlemessage&amp;isappinstalled=0）" target="_blank" rel="noopener">http://wereadteam.github.io/2016/02/22/MLeaksFinder/?from=singlemessage&amp;isappinstalled=0）</a></li>
<li>KVO与KVC原理、KVO、Notification、Delegate优缺点、最推荐的官方文档（<a href="http://www.jianshu.com/p/f1393d10109d）（http://www.tuicool.com/articles/mUVJVb）" target="_blank" rel="noopener">http://www.jianshu.com/p/f1393d10109d）（http://www.tuicool.com/articles/mUVJVb）</a></li>
<li>Runtime（<a href="http://www.ianisme.com/ios/2019.html）" target="_blank" rel="noopener">http://www.ianisme.com/ios/2019.html）</a></li>
<li>block（<a href="http://blog.ibireme.com/2013/11/27/objc-block/）" target="_blank" rel="noopener">http://blog.ibireme.com/2013/11/27/objc-block/）</a></li>
<li>atomic 线程安全、@synchronized（<a href="http://www.cocoachina.com/bbs/read.php?tid-301674.html）（http://www.cnblogs.com/wendingding/p/3805841.html）" target="_blank" rel="noopener">http://www.cocoachina.com/bbs/read.php?tid-301674.html）（http://www.cnblogs.com/wendingding/p/3805841.html）</a></li>
<li>对象的深浅复制（<a href="https://bestswifter.com/differenceofcopybettenswiftandoc/）" target="_blank" rel="noopener">https://bestswifter.com/differenceofcopybettenswiftandoc/）</a></li>
<li>招聘一个靠谱的iOS（<a href="https://github.com/ChenYilong/iOSInterviewQuestions/tree/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88）" target="_blank" rel="noopener">https://github.com/ChenYilong/iOSInterviewQuestions/tree/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88）</a></li>
<li>消息传递机制（<a href="http://objccn.io/issue-7-4/）" target="_blank" rel="noopener">http://objccn.io/issue-7-4/）</a></li>
<li>深入理解Objective-C：Category（<a href="http://tech.meituan.com/DiveIntoCategory.html）" target="_blank" rel="noopener">http://tech.meituan.com/DiveIntoCategory.html）</a></li>
</ul>
<p>强烈推荐第八篇文章，做完这上面的题目基本上可以应付大多数 OC 方面的问题了。</p>
<h3 id="iOS-开发"><a href="#iOS-开发" class="headerlink" title="iOS 开发"></a>iOS 开发</h3><ul>
<li>RunLoop（<a href="http://blog.ibireme.com/2015/05/18/runloop/）" target="_blank" rel="noopener">http://blog.ibireme.com/2015/05/18/runloop/）</a></li>
<li>Cell 图片异步加载优化（<a href="http://www.jianshu.com/p/02ab2b74c451）" target="_blank" rel="noopener">http://www.jianshu.com/p/02ab2b74c451）</a></li>
<li>iOS 函数式编程的实现 &amp;&amp; 响应式编程概念（<a href="http://www.cocoachina.com/ios/20160307/15585.html）" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20160307/15585.html）</a></li>
<li>内存恶鬼drawRect（<a href="http://bihongbo.com/2016/01/03/memoryGhostdrawRect/）" target="_blank" rel="noopener">http://bihongbo.com/2016/01/03/memoryGhostdrawRect/）</a></li>
<li>UIKit 性能调优(主要是UITableView)（<a href="https://bestswifter.com/uikitxing-neng-diao-you-shi-zhan-jiang-jie/）" target="_blank" rel="noopener">https://bestswifter.com/uikitxing-neng-diao-you-shi-zhan-jiang-jie/）</a></li>
<li>优化UITableViewCell高度计算的那些事（<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/）" target="_blank" rel="noopener">http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/）</a></li>
<li>高性能图片架构与设计（<a href="http://zhuanlan.zhihu.com/magilu/20273299）" target="_blank" rel="noopener">http://zhuanlan.zhihu.com/magilu/20273299）</a></li>
<li>轻量化视图控制器（<a href="http://objccn.io/issue-1-1/）" target="_blank" rel="noopener">http://objccn.io/issue-1-1/）</a></li>
<li>UIView的生命周期（<a href="https://bestswifter.com/uiviewlifetime/）" target="_blank" rel="noopener">https://bestswifter.com/uiviewlifetime/）</a></li>
<li>高效设置圆角（<a href="https://bestswifter.com/efficient-rounded-corner/）" target="_blank" rel="noopener">https://bestswifter.com/efficient-rounded-corner/）</a></li>
<li>事件的传递和响应机制（<a href="http://www.jianshu.com/p/2e074db792ba）" target="_blank" rel="noopener">http://www.jianshu.com/p/2e074db792ba）</a></li>
<li>ReactiveCocoa 和 MVVM 入门（<a href="http://yulingtianxia.com/blog/2015/05/21/ReactiveCocoa-and-MVVM-an-Introduction/）" target="_blank" rel="noopener">http://yulingtianxia.com/blog/2015/05/21/ReactiveCocoa-and-MVVM-an-Introduction/）</a></li>
</ul>
<p>其中需要重点了解 runloop，它不仅仅是简单的“跑圈”的 概念，很多问题其实都与它有关，建议认真阅读 ibireme 大神的总结</p>
<h3 id="其他面经"><a href="#其他面经" class="headerlink" title="其他面经"></a>其他面经</h3><p>我是如何同时拿到阿里和腾讯offer的（<a href="https://segmentfault.com/a/1190000002627927#articleHeader5）" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002627927#articleHeader5）</a><br>大三学生拿到阿里,百度实习offer面试经验分享（<a href="http://www.wtoutiao.com/p/e2fwlu.html）" target="_blank" rel="noopener">http://www.wtoutiao.com/p/e2fwlu.html）</a><br>2016年1月TX电面题（<a href="http://blog.csdn.net/xieyupeng520/article/details/50681147）" target="_blank" rel="noopener">http://blog.csdn.net/xieyupeng520/article/details/50681147）</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://bestswifter.com/bat-interview/" target="_blank" rel="noopener">让 BAT 的 Offer 不再难拿 - bestswifter</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/【Android】零基础学-Java？看这篇就够了！/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mayan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mayan`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/【Android】零基础学-Java？看这篇就够了！/" itemprop="url">【Android】零基础学 Java？看这篇就够了！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-04T22:02:13+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/04/【Android】零基础学-Java？看这篇就够了！/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/05/04/【Android】零基础学-Java？看这篇就够了！/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/img/img010.png" alt="image010"></p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-Java-语言概述"><a href="#1-Java-语言概述" class="headerlink" title="1. Java 语言概述"></a>1. Java 语言概述</h3><p>Java 是 SUN（Stanford University Network，斯坦福大学网络公司）1995 年推出的一门高级编程语言，是一种面向 Internet 的编程语言。</p>
<h3 id="2-Java-语言的三种技术架构"><a href="#2-Java-语言的三种技术架构" class="headerlink" title="2. Java 语言的三种技术架构"></a>2. Java 语言的三种技术架构</h3><p><strong>Java</strong> <strong>EE</strong>（Java Platform，Enterprise Edition，企业版），Java 5.0 以前称为 J2EE。Java EE 是在 Java SE 的基础上构建的。简单点说 Java EE 是用来做网站的。</p>
<p><strong>Java</strong> <strong>SE</strong>（Java Platform，Standard Edition，标准版），Java 5.0 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。简单点说 Java SE 是用来做电脑上运行的软件的。</p>
<p><strong>Java</strong> <strong>ME</strong>（Java Platform，Micro Edition，微型版），Java 5.0 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备上运行的应用程序提供环境。简单点说 Java ME 是用来做手机软件的。</p>
<h3 id="3-Java-语言特点"><a href="#3-Java-语言特点" class="headerlink" title="3. Java 语言特点"></a>3. Java 语言特点</h3><p><strong>跨平台性</strong>。只需在操作系统上安装 Java 虚拟机（JVM，Java Virtual Machine）即可，由 JVM 来负责 Java 程序在该系统中的运行。</p>
<h3 id="4-Java-语言环境搭建"><a href="#4-Java-语言环境搭建" class="headerlink" title="4. Java 语言环境搭建"></a>4. Java 语言环境搭建</h3><p><strong>JRE</strong>（Java Runtime Environment，Java 运行环境）。包括 JVM 和 Java 程序所需的核心类库等。</p>
<p><strong>JDK</strong>（Java Development Kit，Java 开发工具包）。其中包含 Java 的开发工具（编译工具、打包工具等）和 JRE，所以安装了 JDK 就不用再单独安装 JRE 了。下载地址：<a href="http://www.oracle.com" target="_blank" rel="noopener">http://www.oracle.com</a></p>
<p><img src="/img/img011.png" alt="image011"></p>
<p>JRE 仅仅是运行工具，如需要开发工具则需搭建 JDK。JDK 开发完成的 Java 程序，交给 JRE 去运行。</p>
<h2 id="二、初体验"><a href="#二、初体验" class="headerlink" title="二、初体验"></a>二、初体验</h2><h3 id="Hello-Java"><a href="#Hello-Java" class="headerlink" title="Hello Java"></a>Hello Java</h3><p>编写如下代码保存为 Demo.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用终端，在 Demo.java 文件当前目录，输入如下命令进行编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac Demo.java</span><br></pre></td></tr></table></figure>
<p>编译成功后在 Demo.java 文件当前目录下生成 Demo.class 文件，输入如下命令运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java Demo</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Java</span><br></pre></td></tr></table></figure>
<h3 id="Mac-使用-Sublime-Text-3-搭建-Java-环境"><a href="#Mac-使用-Sublime-Text-3-搭建-Java-环境" class="headerlink" title="Mac 使用 Sublime Text 3 搭建 Java 环境"></a>Mac 使用 Sublime Text 3 搭建 Java 环境</h3><p>Sublime Text 默认的 Java 处理方式仅仅是编译，Build 后会生成一个 .class 文件，而没有去运行，这时候就需要改配置文件达到编译 + 运行的目的。</p>
<p><strong>1.</strong> <strong>Tools</strong> <strong>—&gt;</strong> <strong>Build</strong> <strong>System</strong> <strong>—&gt;</strong> <strong>New</strong> <strong>Build</strong> <strong>System</strong></p>
<p><img src="/img/img012.png" alt="image012"></p>
<p><strong>2.</strong> <strong>添加如下代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"shell_cmd"</span>: <span class="string">"javac -encoding utf-8 $file_name &amp;&amp; java $file_base_name"</span>,</span><br><span class="line">    <span class="string">"file_regex"</span>: <span class="string">"^ *\\[javac\\] (,+):([0-9]+):() (.*)$"</span>,</span><br><span class="line">    <span class="string">"selector"</span>: <span class="string">"source.java"</span>,</span><br><span class="line">    <span class="string">"encoding"</span>: <span class="string">"utf-8"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.</strong> <strong>直接保存，名字随意</strong></p>
<p><img src="/img/img013.png" alt="image013"></p>
<p><strong>4.</strong> <strong>Tools</strong> <strong>—&gt;</strong> <strong>Build</strong> <strong>System</strong> <strong>—&gt;</strong> <strong>选择上一步保存的配置文件</strong></p>
<p><img src="/img/img014.png" alt="image014"></p>
<p><strong>5.</strong> <strong>cmd</strong> <strong>+</strong> <strong>B</strong> <strong>编译运行，就有输出结果了</strong></p>
<p><img src="/img/img015.png" alt="image015"></p>
<h2 id="三、基本语法"><a href="#三、基本语法" class="headerlink" title="三、基本语法"></a>三、基本语法</h2><h3 id="1-名称规范"><a href="#1-名称规范" class="headerlink" title="1. 名称规范"></a>1. 名称规范</h3><ul>
<li><p>包名：多单词组成时，所有字母都小写 xxxyyyzzz</p>
</li>
<li><p>类名、接口名：多单词组成时，所有单词首字母大写 XxxYyyZyy</p>
</li>
<li><p>变量名和函数名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写 xxxYyyZzz</p>
</li>
<li><p>常量名：多单词组成时，每个单词用下划线连接，所有字母都大写 XXX_YYY_ZZZ</p>
</li>
</ul>
<h3 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2. 基本数据类型"></a>2. 基本数据类型</h3><p>Java 语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。</p>
<p><strong>整数型</strong>：byte、short（2 byte）、int（4 byte）、long（8 byte）</p>
<blockquote>
<p>1 byte = 8 bit，1 字节 = 8 位</p>
<p>1 byte 取值范围是 -128 ~ 127，也就是 -2^7 ~ 2^7-1</p>
<p>1 short 取值范围是 -32768 ~ 32767，也就是 -2^15 ~ 2^15-1</p>
<p>1 int 取值范围是 -2^31 ~ 2^31-1</p>
</blockquote>
<p><strong>浮点型</strong>：float（4 byte）、double（8 byte）</p>
<p><strong>字符型</strong>：char（1 byte）</p>
<blockquote>
<p>1 char 取值范围是 0 ~ 65535，也就是 0 ~ 2^16-1</p>
</blockquote>
<p><strong>布尔型</strong>：boolean（1 byte）</p>
<h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><p><strong>&amp;</strong>：无论左边是 true 还是 false，右边都运算；</p>
<p><strong>&amp;&amp;</strong>：当左边为 false 时，右边不运算；</p>
<p><strong>|</strong>：无论左边是 true 还是 false，右边都运算；</p>
<p><strong>||</strong>：当左边为 true 时，右边不运算；</p>
<p><strong>^</strong>：两边结果相同为 false，两边结果不同为 true</p>
<blockquote>
<p>true ^ ture   = false;</p>
<p>false ^ false = false;</p>
<p>true ^ false  = true;</p>
<p>false ^ true  = true;</p>
</blockquote>
<blockquote>
<p>应用场景</p>
<ol>
<li><p>一个数异或同一个数两次，结果不变（7^4^4 = 7），一般用于加密解密</p>
</li>
<li><p>数值交换</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; n = n^m;</span><br><span class="line">&gt; m = n^m;</span><br><span class="line">&gt; n = n^m;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这种方法比加减方法好，因为如果 n 和 m 的值非常大，容易超出 int 范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; n = n+m;</span><br><span class="line">&gt; m = n-m;</span><br><span class="line">&gt; n = n-m;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h3><p><strong>左移</strong> <strong>/</strong> <strong>右移</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> &lt;&lt; <span class="number">2</span> = <span class="number">12</span>;  <span class="comment">// 相当于 3 乘以 2 ^ 2，3 * 4</span></span><br><span class="line"><span class="number">6</span> &gt;&gt; <span class="number">1</span> = <span class="number">3</span>;   <span class="comment">// 相当于 6 除以 2 ^ 1，6 / 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>应用场景：乘法需要转换成二进制位位相乘，比较费事，使用位运算节省时间</p>
</blockquote>
<p><strong>有符号位移</strong> <strong>/</strong> <strong>无符号位移</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">6</span> &gt;&gt; <span class="number">1</span>;   <span class="comment">// 右移后，左边高位用 1 补位</span></span><br><span class="line">-<span class="number">6</span> &gt;&gt;&gt; <span class="number">1</span>;  <span class="comment">// 右移后，左边高位用 0 补位</span></span><br></pre></td></tr></table></figure>
<p><strong>与运算</strong> <strong>/</strong> <strong>或运算</strong> <strong>/</strong> <strong>异或运算</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> &amp; <span class="number">5</span> = <span class="number">4</span>;</span><br><span class="line"><span class="number">6</span> | <span class="number">5</span> = <span class="number">7</span>;</span><br><span class="line"><span class="number">6</span> ^ <span class="number">5</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-循环语句"><a href="#5-循环语句" class="headerlink" title="5. 循环语句"></a>5. 循环语句</h3><h4 id="打印九九乘法表"><a href="#打印九九乘法表" class="headerlink" title="打印九九乘法表"></a>打印九九乘法表</h4><p>下面例子不是介绍九九乘法表的算法，而是 <code>\t</code> 制表符的应用。如果用空格，打印中在某一行会没有对齐，如果用制表符则不用考虑这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        System.out.println(j + <span class="string">"*"</span> + i + <span class="string">"="</span> + j*i + <span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="跳出多层循环嵌套"><a href="#跳出多层循环嵌套" class="headerlink" title="跳出多层循环嵌套"></a>跳出多层循环嵌套</h4><p>如下例子，仅仅打印了 <code>1*1=1</code> 就跳出循环了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">w: <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    q: <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">           System.out.println(j + <span class="string">"*"</span> + i + <span class="string">"="</span> + j*i + <span class="string">"\t"</span>);</span><br><span class="line">           <span class="keyword">break</span> w;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];  <span class="comment">// 二维数组第二维可以不定义长度，默认第一维指向为空</span></span><br><span class="line">System.out.println(arr[<span class="number">1</span>]);  <span class="comment">// 打印结果为 null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="数组存储原理"><a href="#数组存储原理" class="headerlink" title="数组存储原理"></a>数组存储原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>以上面创建数组为例，x 存储到栈内存中，new int[3] 存储到堆内存中。x 存储的不是 new int[3] 本身，而是 new int[3] 的起始内存地址（例如是 0x0079），也就是 x 指向了该内存地址。并且堆内存中，只要被创建，就会有初始化值。</p>
<p>当不想要 x 这个数组了，则将 x 置为 null，x 不指向之前的地址了，数组在堆内存中则不被使用了。java 虚拟机则将该数组视为垃圾，但是不会立刻将其清除掉，会不定时的启动垃圾回收机制，将该数组实体在堆内存中清除。</p>
<blockquote>
<p>垃圾回收机制不同于 c++，需要程序员自己将堆内存中垃圾清除，java 将这里做了优化。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">System.out.println(arr2);</span><br></pre></td></tr></table></figure>
<p>打印的结果为：<code>[I@43556938</code>，<code>[</code> 代表数组，<code>I</code> 代表 int 数据类型，<code>@</code> 右边的为数组内存存放地址，其为哈希算法算出来的哈希值。如果是二维数组，其打印结果为 <code>[[I@43556938</code></p>
<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>实际开发中只调用 <code>Arrays.sort(arr)</code> 即可实现排序，但是需要声明 <code>import java.util.Arrays</code> 包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-进制转换"><a href="#7-进制转换" class="headerlink" title="7. 进制转换"></a>7. 进制转换</h3><h4 id="十进制转换成二进制"><a href="#十进制转换成二进制" class="headerlink" title="十进制转换成二进制"></a>十进制转换成二进制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Integer.toBinaryString(<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        toBin(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toBin</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            sb.append(num % <span class="number">2</span>);</span><br><span class="line">            num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sb.reverse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法三（查表法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        toBin(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toBin</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            sb.append(chars[num &amp; <span class="number">1</span>]);</span><br><span class="line">            num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sb.reverse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="十进制转换成十六进制"><a href="#十进制转换成十六进制" class="headerlink" title="十进制转换成十六进制"></a>十进制转换成十六进制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        toHex(<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">8</span>; x++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 15 的二进制表达形式为 1111，num 和 15 与运算结果为最后四位的值</span></span><br><span class="line">            <span class="keyword">int</span> tmp = num &amp; <span class="number">15</span>;              </span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                sb.append((<span class="keyword">char</span>)(tmp - <span class="number">10</span> + <span class="string">'a'</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            num = num &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sb.reverse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法三（查表法）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        toHex(<span class="number">60</span>);</span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">8</span>; x++) &#123;</span><br><span class="line"></span><br><span class="line">            sb.append(chars[num &amp; <span class="number">15</span>]);</span><br><span class="line">            num = num &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sb.reverse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h2><p>面向对象三个特征：</p>
<ul>
<li><strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。</li>
</ul>
<p>两种变量：</p>
<ul>
<li>成员变量：定义在函数之外，存在堆内存中。</li>
<li>局部变量：定义在函数之内，存在栈内存中。</li>
</ul>
<h3 id="1-重载"><a href="#1-重载" class="headerlink" title="1. 重载"></a>1. 重载</h3><p><strong>定义</strong>：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类似不同即可。</p>
<p><strong>应用场景</strong>：当定义的功能相同，但参与运算的未知内容不同。那么，这时就定义一个函数名称以表示其功能，方便阅读，而通过参数列表的不同来区分多个同名函数。</p>
<p><strong>判断是否重载</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> b, <span class="keyword">double</span> c)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">a.</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> y, <span class="keyword">double</span> z)</span></span>&#123;&#125;  <span class="comment">// 没有，因为和原函数一样</span></span><br><span class="line"></span><br><span class="line">b.</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> c)</span></span>&#123;&#125;  <span class="comment">// 重载，因为参数类型不同   </span></span><br><span class="line"></span><br><span class="line">c.</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> b)</span></span>&#123;&#125;  <span class="comment">// 重载，因为参数个数不同</span></span><br><span class="line"></span><br><span class="line">d.</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> b, <span class="keyword">double</span> c)</span></span>&#123;&#125;  <span class="comment">// 没有，重载和返回值类型没有关系</span></span><br></pre></td></tr></table></figure>
<h3 id="2-私有权限修饰符"><a href="#2-私有权限修饰符" class="headerlink" title="2. 私有权限修饰符"></a>2. 私有权限修饰符</h3><p><strong>private</strong>：私有权限修饰符，用于修饰类中的成员变量、成员函数。只能在该类中访问，在外部不能访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I`m running."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.age = <span class="number">20</span>;</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，Person 类的 <code>age</code> 不可以赋值，同时 <code>run()</code> 方法也不可调用。</p>
<h3 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3. 构造函数"></a>3. 构造函数</h3><p><strong>构造函数</strong>：可以用于给对象进行初始化，当一个类中没有定义构造函数，那么系统会默认给该类加入一个空参数的构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 就相当于重写 init 初始化</span></span><br><span class="line">    Person() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String n) &#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String n, <span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">        <span class="keyword">this</span>.age = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person: name = "</span> + name + <span class="string">", age = "</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(); </span><br><span class="line">        p1.say();</span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"mayan"</span>);</span><br><span class="line">        p2.say();</span><br><span class="line"></span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"mayan"</span>, <span class="number">25</span>);</span><br><span class="line">        p3.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person: name = <span class="keyword">null</span>, age = <span class="number">0</span></span><br><span class="line">Person: name = mayan, age = <span class="number">0</span></span><br><span class="line">Person: name = mayan, age = <span class="number">25</span></span><br></pre></td></tr></table></figure>
<h3 id="4-静态修饰符"><a href="#4-静态修饰符" class="headerlink" title="4. 静态修饰符"></a>4. 静态修饰符</h3><p>static 是一个修饰符，用于修饰成员变量/成员函数（不能修饰局部变量/局部函数）。</p>
<h4 id="类变量和实例变量的区别"><a href="#类变量和实例变量的区别" class="headerlink" title="类变量和实例变量的区别"></a>类变量和实例变量的区别</h4><p>被 static 修饰的静态成员变量，称为类变量；不被 static 修饰的成员变量，称为实例变量，也就是对象变量。</p>
<ol>
<li>存放位置，类变量随着类的加载而存在于方法区中；实例变量随着对象的建立而存在于堆内存中。</li>
<li>生命周期，类变量随着类的消失而消失；实例变量随着对象的消失而消失。</li>
<li>调用方式，类变量可以被类名或者对象调用；实例变量必须被对象调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> String country = <span class="string">"CN"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	    Person p = <span class="keyword">new</span> Person(); </span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 打印的结果都是 "CN"</span></span><br><span class="line">	    System.out.println(p.country);</span><br><span class="line">	    System.out.println(Person.country);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态的利弊"><a href="#静态的利弊" class="headerlink" title="静态的利弊"></a>静态的利弊</h4><ul>
<li>利处：对对象的共享数据进行单独空间存储，节省空间。没有必要每一个对象中都存储一份，可以直接被类名调用。</li>
<li>弊端：生命周期过长，访问出现局限性，只能访问静态。</li>
</ul>
<h3 id="5-主函数"><a href="#5-主函数" class="headerlink" title="5. 主函数"></a>5. 主函数</h3><p>main 函数解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public : 代表该函数访问权限是最大的 </span></span><br><span class="line"><span class="comment">// static : 代表主函数随着类的加载就已经存在了 </span></span><br><span class="line"><span class="comment">// void   : 主函数没有具体的返回值 </span></span><br><span class="line"><span class="comment">// main   : 不是关键字，但是是一个特殊的单词，可以被 jvm 识别 </span></span><br><span class="line"><span class="comment">// args   : arguments 的缩写，意思为参数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-类文档"><a href="#6-类文档" class="headerlink" title="6. 类文档"></a>6. 类文档</h3><p>新建一个文件 <code>Tool.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这是一个基本函数工具类，该类目前提供了，获取两个数中最大值、最小值两个方法</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> mayan</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    获取两个数中最大值</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> num1 两个比较的数中其一</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> num2 两个比较的数中其二</span></span><br><span class="line"><span class="comment">    <span class="doctag">@return</span> 返回其中最大的数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> num1 &gt; num2 ? num1 : num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    获取两个数中最小值</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> num1 两个比较的数中其一</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> num2 两个比较的数中其二</span></span><br><span class="line"><span class="comment">    <span class="doctag">@return</span> 返回其中最小的数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num1 &lt; num2 ? num1 : num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Demo.java</code> 文件中调用工具类中的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = Tool.max(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入该工具类所在的文件夹，在终端输入如下命令，可在该路径下生成文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javadoc -d myhelp -author -version Tool.java -encoding utf-<span class="number">8</span> -charset utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="7-静态代码块"><a href="#7-静态代码块" class="headerlink" title="7. 静态代码块"></a>7. 静态代码块</h3><p>静态代码块随着类的加载而执行，并且只执行一次，用于给类进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"I`m a man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"I`m "</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I`m crying"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.cry();</span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        p2.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下，其中打印年龄的为代码块，每次创建对象都会运行一次，因为 age 的初始化在其前面，所以代码块里面可以调用 <code>this.age</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I`m a man</span><br><span class="line">I`m <span class="number">26</span></span><br><span class="line">I`m crying</span><br><span class="line">I`m <span class="number">26</span></span><br><span class="line">I`m crying</span><br></pre></td></tr></table></figure>
<h3 id="8-对象初始化过程"><a href="#8-对象初始化过程" class="headerlink" title="8. 对象初始化过程"></a>8. 对象初始化过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>上面初始化方法都做了哪些事情？</p>
<ol>
<li>首先 javac 编译 .java 源文件形成 .class 字节码文件；</li>
<li>JVM 的类加载器将 Person.class 文件加载到内存中；</li>
<li>先初始化类中静态属性，再初始化静态代码块；</li>
<li>在堆内存中开辟空间，分配内存地址；</li>
<li>初始化特有属性；</li>
<li>初始化构造代码块；</li>
<li>初始化构造函数；</li>
<li>将内存地址赋给栈内存中的 p 变量。</li>
</ol>
<h3 id="9-单例设计模式"><a href="#9-单例设计模式" class="headerlink" title="9. 单例设计模式"></a>9. 单例设计模式</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">new</span> Single();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Single.class) &#123;  <span class="comment">// 加锁</span></span><br><span class="line">				<span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">					s = <span class="keyword">new</span> Single();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两种单例方法的调用，打印结果都相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Single s1 = Single.getInstance();</span><br><span class="line">		Single s2 = Single.getInstance();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"s1 = "</span> + s1 + <span class="string">" s2 = "</span> + s2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 = Single@<span class="number">2</span>cfb4a64 s2 = Single@<span class="number">2</span>cfb4a64</span><br></pre></td></tr></table></figure>
<h3 id="10-继承"><a href="#10-继承" class="headerlink" title="10. 继承"></a>10. 继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Person</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Student s = <span class="keyword">new</span> Student();</span><br><span class="line">		s.name = <span class="string">"student"</span>;</span><br><span class="line">		s.age = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">		Worker w = <span class="keyword">new</span> Worker();</span><br><span class="line">		w.name = <span class="string">"worker"</span>;</span><br><span class="line">		w.age = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"Student - "</span> + <span class="string">"name: "</span> + s.name + <span class="string">" age: "</span> + s.age);</span><br><span class="line">		System.out.println(<span class="string">"Worker - "</span> + <span class="string">"name: "</span> + w.name + <span class="string">" age: "</span> + w.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student - name: student age: <span class="number">8</span></span><br><span class="line">Worker - name: worker age: <span class="number">26</span></span><br></pre></td></tr></table></figure>
<h4 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h4><ul>
<li>被 final 修饰的类不可以被继承</li>
<li>被 final 修饰的函数不能被复写</li>
<li>被 final 修饰的成员变量/局部变量是一个常量，只能赋值一次。</li>
</ul>
<h3 id="11-抽象类"><a href="#11-抽象类" class="headerlink" title="11. 抽象类"></a>11. 抽象类</h3><ul>
<li>抽象方法一定定义在抽象类中；</li>
<li>抽象方法和抽象类都必须被 abstract 关键字修饰；</li>
<li>抽象类不可以用 new 创建对象，因为调用抽象方法没意义；</li>
<li>抽象类中的方法要被使用，必须由子类复写所有的抽象方法后，建立子类对象调用；</li>
<li>如果子类只覆盖部分抽象方法，那么该子类还是一个抽象类；</li>
<li>特殊用法：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"睡觉"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Science_student</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"学习科学"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Art_student</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"学习艺术"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Science_student ss = <span class="keyword">new</span> Science_student();</span><br><span class="line">		ss.study();</span><br><span class="line"></span><br><span class="line">		Art_student as = <span class="keyword">new</span> Art_student();</span><br><span class="line">		as.study();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">学习科学</span><br><span class="line">学习艺术</span><br></pre></td></tr></table></figure>
<h4 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h4><p>在定义功能时，功能的一部分是确定的，但是有一部分是不确定的。确定的部分在使用不确定的部分，将不确定的部分暴露出去，由该类的子类来完成。</p>
<p>应用场景：获取一段程序运行的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GetTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前时间</span></span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		runcode();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前时间</span></span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"毫秒："</span> + (end - start));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">runcode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetErgodicTime</span> <span class="keyword">extends</span> <span class="title">GetTime</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10000</span>; x++) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		GetErgodicTime t = <span class="keyword">new</span> GetErgodicTime();</span><br><span class="line">		t.getTime();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="number">9997</span></span><br><span class="line"><span class="number">9998</span></span><br><span class="line"><span class="number">9999</span></span><br><span class="line">毫秒：<span class="number">79</span></span><br></pre></td></tr></table></figure>
<h3 id="12-接口"><a href="#12-接口" class="headerlink" title="12. 接口"></a>12. 接口</h3><p>接口初期理解，可以认为是一个特殊的抽象类，当抽象类中的方法都是抽象的，那么该类可以通过接口的形式来表示。</p>
<ul>
<li>class：用于定义类</li>
<li>interface：用于定义接口</li>
</ul>
<p>接口中的成员都有固定修饰符</p>
<ul>
<li>常量：public static final</li>
<li>方法：public abstract</li>
</ul>
<p><strong>基本应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">3</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Test t = <span class="keyword">new</span> Test();</span><br><span class="line">		System.out.println(t.NUM);</span><br><span class="line">		System.out.println(Test.NUM);</span><br><span class="line">		System.out.println(Inter.NUM);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>多继承</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">3</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">InterA</span>, <span class="title">InterB</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Test t = <span class="keyword">new</span> Test();</span><br><span class="line">		System.out.println(t.NUM);</span><br><span class="line">		System.out.println(Test.NUM);</span><br><span class="line">		System.out.println(Inter.NUM);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>接口继承接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">3</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterB</span> <span class="keyword">extends</span> <span class="title">InterA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">InterB</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Test t = <span class="keyword">new</span> Test();</span><br><span class="line">		System.out.println(t.NUM);</span><br><span class="line">		System.out.println(Test.NUM);</span><br><span class="line">		System.out.println(Inter.NUM);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>抽象类和接口的区别</p>
<ol>
<li>抽象类可以有构造方法，接口不能有构造方法 </li>
<li>抽象类中可以有普通成员变量，接口中没有普通成员变量 </li>
<li>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须是抽象的，不能有非抽象的普通方法 </li>
<li>抽象类中抽象方法的访问类型可以是 public、protected 和默认类型，接口中的抽象方法只能是 public 类型，并且默认即为 public abstract 类型 </li>
<li>抽象类中可以包含静态方法，接口中不能包含静态方法 </li>
<li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是 public static final 类型</li>
<li>一个类只能继承一个抽象类，一个类可以实现多个接口</li>
<li>抽象类的设计理念是 <code>is a</code> 关系（继承），接口的设计理念是 <code>like a</code> 关系（功能扩展）</li>
</ol>
<h3 id="13-多态"><a href="#13-多态" class="headerlink" title="13. 多态"></a>13. 多态</h3><ul>
<li>多态的体现：父类的引用指向了自己的子类对象。</li>
<li>多态的前提：必须是类与类之间有关系，要么继承，要么实现。</li>
<li>多态的好处：提高了程序的扩展性。</li>
<li>多态的弊端：只能使用父类的引用访问父类中的成员。</li>
</ul>
<p><strong>基本应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String thing)</span> </span>&#123;</span><br><span class="line">		System.out.println(thing);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"cat: 吃鱼"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog: 吃骨头"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Animal c = <span class="keyword">new</span> Cat();</span><br><span class="line">		Animal d = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">		function(c);</span><br><span class="line">		function(d);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(Animal a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 先吃</span></span><br><span class="line">		a.eat();</span><br><span class="line"></span><br><span class="line">	 	<span class="comment">// 然后实现动作，正常不会这样判断，拓展性不好</span></span><br><span class="line">	 	<span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">	 		</span><br><span class="line">	 		Cat c = (Cat)a;</span><br><span class="line">	 		c.doSomething(<span class="string">"cat: 捉老鼠"</span>);</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line"></span><br><span class="line">	 		Dog d = (Dog)a;</span><br><span class="line">	 		d.doSomething(<span class="string">"dog: 看家"</span>);</span><br><span class="line">	 	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat: 吃鱼</span><br><span class="line">cat: 捉老鼠</span><br><span class="line">dog: 吃骨头</span><br><span class="line">dog: 看家</span><br></pre></td></tr></table></figure>
<p><strong>特殊情况 1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String name = <span class="string">"Father"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String name = <span class="string">"Child"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Father f = <span class="keyword">new</span> Child();</span><br><span class="line">		System.out.println(f.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Father</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>在多态中，非静态成员变量无论编译和运行，都参考左边（引用型变量所属的类）。</li>
</ol>
<p><strong>特殊情况 2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Father Method"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Father StaticMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Child Method"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Child StaticMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Father f = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">		f.method();</span><br><span class="line">		f.staticMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child Method</span><br><span class="line">Father StaticMethod</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>在多态中，静态成员函数无论编译和运行，都参考左边（引用型变量所属的类）；</li>
<li>非静态区用 this 来调用对象，所以会调用子类方法；而静态区用 Father 来调用对象，所以会调用父类方法。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/22/【iOS】保持界面流畅的技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mayan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mayan`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/【iOS】保持界面流畅的技巧/" itemprop="url">【iOS】保持界面流畅的技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T14:03:55+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/22/【iOS】保持界面流畅的技巧/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/22/【iOS】保持界面流畅的技巧/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文内容整理于以下文章：</p>
<ol>
<li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧 - ibireme</a></li>
<li><a href="https://segmentfault.com/a/1190000006699632" target="_blank" rel="noopener">使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能</a></li>
<li><a href="http://chars.tech/pieces/2017/07/03/ios-corner-radius.html" target="_blank" rel="noopener">从 iOS 的图片圆角想到渲染 - Chars
</a></li>
<li><a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范 + 性能测试</a></li>
<li><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">优化 UITableViewCell 高度计算的那些事 - sunnyxx</a></li>
<li><a href="http://www.cnblogs.com/ludashi/p/5895725.html" target="_blank" rel="noopener">iOS 开发之多种 Cell 高度自适应实现方案的 UI 流畅度分析 - 青玉伏案</a></li>
</ol>
</blockquote>
<h2 id="1-屏幕显示图像的原理"><a href="#1-屏幕显示图像的原理" class="headerlink" title="1. 屏幕显示图像的原理"></a>1. 屏幕显示图像的原理</h2><p>首先从过去的显像管显示器（CRT）原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。</p>
<p>当电子枪换到新的一行，准备进行扫描时，显示器会发出一个<strong>水平同步信号</strong>（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个<strong>垂直同步信号</strong>（vertical synchronization），简称 VSync。</p>
<p>显示器通常以固定频率进行刷新，这个刷新率就是<strong>垂直同步信号</strong>产生的频率。尽管液晶显示器（LCD）的成像原理和显像管显示器截然不同，但是由于历史原因，液晶显示器仍然需要按照一定的刷新频率向 GPU 获取新的图像用于显示。</p>
<p><img src="/img/img001.png" alt="image001"></p>
<p>通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区（FrameBuffer），随后视频控制器会按照<strong>垂直同步信号</strong>逐行读取帧缓冲区的数据，经过数模转换传递给显示器显示。</p>
<p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都会有比较大的效率问题。为了解决效率问题，显示系统引入双缓冲机制，即同时使用<strong>帧缓冲区（frame buffer）</strong>和<strong>后备缓冲区（back buffer）</strong>。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p>
<p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p>
<p><img src="/img/img002.jpg" alt="image002"></p>
<p>为了解决这个问题，GPU 通常有一个机制叫做<strong>垂直同步</strong>（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的<strong>垂直同步信号</strong>发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p>
<p>iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。</p>
<h2 id="2-卡顿产生的原因"><a href="#2-卡顿产生的原因" class="headerlink" title="2. 卡顿产生的原因"></a>2. 卡顿产生的原因</h2><p><img src="/img/img003.png" alt="image003"></p>
<p>在<strong>垂直同步信号</strong>到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次<strong>垂直同步信号</strong>到来时显示到屏幕上。由于垂直同步的机制，如果在一个<strong>垂直同步信号</strong>时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>
<p>从上图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，需要分别对 CPU 和 GPU 压力进行评估和优化。</p>
<h2 id="3-CPU-资源消耗原因和解决方案"><a href="#3-CPU-资源消耗原因和解决方案" class="headerlink" title="3. CPU 资源消耗原因和解决方案"></a>3. CPU 资源消耗原因和解决方案</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。</p>
<ol>
<li>尽量用轻量的对象代替重量的对象：比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。</li>
<li>如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。</li>
<li>通过 Xib/Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里不要使用。</li>
<li>如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</li>
</ol>
<h3 id="对象调整"><a href="#对象调整" class="headerlink" title="对象调整"></a>对象调整</h3><p>对象的调整也经常是消耗 CPU 资源的地方，这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过 runtime 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p>
<h3 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h3><p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Autolayout"><a href="#Autolayout" class="headerlink" title="Autolayout"></a>Autolayout</h3><p>Autolayout 是苹果本身提倡的技术，但是对于复杂视图来说会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href="http://pilky.me/36/" target="_blank" rel="noopener">http://pilky.me/36/</a>。</p>
<h3 id="文本计算"><a href="#文本计算" class="headerlink" title="文本计算"></a>文本计算</h3><p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 <code>[string boundingRectWithSize:options:context:]</code> 来计算文本宽高，用 <code>[string drawWithRect:options:attributes:context:]</code> 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p>
<p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p>
<h3 id="文本渲染"><a href="#文本渲染" class="headerlink" title="文本渲染"></a>文本渲染</h3><p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或者最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）。而且 CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>
<h3 id="图片的解码"><a href="#图片的解码" class="headerlink" title="图片的解码"></a>图片的解码</h3><p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>
<h3 id="图像的绘制"><a href="#图像的绘制" class="headerlink" title="图像的绘制"></a>图像的绘制</h3><p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 <code>[UIView drawRect:]</code> 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-GPU-资源消耗原因和解决方案"><a href="#4-GPU-资源消耗原因和解决方案" class="headerlink" title="4. GPU 资源消耗原因和解决方案"></a>4. GPU 资源消耗原因和解决方案</h2><p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p>
<h3 id="纹理的渲染（图片和视图）"><a href="#纹理的渲染（图片和视图）" class="headerlink" title="纹理的渲染（图片和视图）"></a>纹理的渲染（图片和视图）</h3><p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture（是一个对 GPU 只读的资源，其有着一些属性，宽度、高度、色彩通道数量等）。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>
<p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096×4096，更详细的资料可以看这里：<a href="http://www.iosres.com" target="_blank" rel="noopener">iosres.com</a>。所以，尽量不要让图片和视图的大小超过这个值。</p>
<h3 id="视图的混合（opaque-属性）"><a href="#视图的混合（opaque-属性）" class="headerlink" title="视图的混合（opaque 属性）"></a>视图的混合（opaque 属性）</h3><p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性 YES 以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>
<blockquote>
<p>opaque 属性表示当前控件是否不透明，UIView 默认值是 YES，但 UIButton 等子类的默认值都是 NO。为了提升性能，如果开发中 UIView 是不透明的，opaque 设置为 YES，如果  Alpha 小于 1，则 opaque 应该设置为 NO。</p>
</blockquote>
<h3 id="图形的生成（离屏渲染）"><a href="#图形的生成（离屏渲染）" class="headerlink" title="图形的生成（离屏渲染）"></a>图形的生成（离屏渲染）</h3><h4 id="a-当前屏幕渲染与离屏渲染"><a href="#a-当前屏幕渲染与离屏渲染" class="headerlink" title="a. 当前屏幕渲染与离屏渲染"></a>a. 当前屏幕渲染与离屏渲染</h4><p>OpenGL 中 GPU 屏幕渲染有两种方式：</p>
<ul>
<li>On-Screen Rendering，当前屏幕渲染，指的是 GPU 的渲染操作是在当前用于显示的屏幕缓冲区中进行。</li>
<li>Off-Screen Rendering，离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</li>
</ul>
<p>相比于当前屏幕渲染，离屏渲染的代价是很高的。首先要创建一个新的缓冲区，然后需要多次切换上下文环境。其中创建新缓冲区代价并不算太大，付出代价最大的是上下文切换。</p>
<blockquote>
<p>上下文切换：不管是在 GPU 渲染过程中，还是一直所熟悉的进程切换，上下文切换在哪里都是一个相当耗时的操作。首先我要保存当前屏幕渲染环境，然后切换到一个新的绘制环境，申请绘制资源，初始化环境，然后开始一个绘制，绘制完毕后销毁这个绘制环境，切换到当前屏幕渲染或者再开始一个新的离屏渲染重复之前的操作。</p>
</blockquote>
<h4 id="b-离屏渲染触发方式"><a href="#b-离屏渲染触发方式" class="headerlink" title="b. 离屏渲染触发方式"></a>b. 离屏渲染触发方式</h4><ul>
<li>drawRect</li>
<li>layer.shouldRasterize = true;</li>
<li>layer.masksToBounds / layer.shadow<ul>
<li>shouldRasterize（光栅化）</li>
<li>masks（遮罩）</li>
<li>shadows（阴影）</li>
<li>edge antialiasing（抗锯齿）</li>
<li>group opacity（不透明）</li>
</ul>
</li>
<li>Text（UILabel, CATestLayer, Core Text…）</li>
</ul>
<p>其中 shouldRasterize（光栅化）是比较特别的一种，如果 <code>CALayer.shouldRasterize =  YES</code>，在其他属性触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的 layer 及其 sublayers 没有发生改变，在下一帧的时候可以直接复用。这样会隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，相当于把 GPU 的操作转到 CPU 上了，生成位图缓存，直接读取复用，这将在很大程度上提升渲染性能。但是对于经常变动的内容，建议不要开启，否则会造成性能的浪费。比如 TableViewCell 重绘是很频繁的，因为复用，cell 需要不断的重绘，如果此时设置了 cell.layer 可光栅化，则会造成大量的离屏渲染，降低图形性能。</p>
<blockquote>
<p>光栅化：将图转化成一个个栅格组成的图像，每个元素对应帧缓冲区中的一个像素。</p>
</blockquote>
<p>对于圆角的优化，目前可以考虑三方面：</p>
<ul>
<li>第一，用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果；</li>
<li>第二，将图片切割成指定圆角的样式；</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line"><span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, -rect.size.height);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> minSize = MIN(<span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line"><span class="keyword">if</span> (borderWidth &lt; minSize / <span class="number">2.0</span>) &#123;</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectInset</span>(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:<span class="built_in">CGSizeMake</span>(radius, borderWidth)];</span><br><span class="line">    <span class="built_in">CGContextSaveGState</span>(context);</span><br><span class="line">    [path addClip];</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, rect, <span class="keyword">self</span>.CGImage);</span><br><span class="line">    <span class="built_in">CGContextRestoreGState</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">image = [image dd_imageByCornerRadius:radius borderedColor:borderColor borderWidth:borderWidth corners:corners];</span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>第三，使用贝塞尔曲线，利用 CALayer 层绘制指定圆角样式的 mask 遮盖 View。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">[<span class="keyword">self</span> drawAtPoint:<span class="built_in">CGPointZero</span>];</span><br><span class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line"><span class="built_in">CGFloat</span> strokeInset = borderWidth / <span class="number">2.0</span>;</span><br><span class="line"><span class="built_in">CGRect</span> strokeRect = <span class="built_in">CGRectInset</span>(rect, strokeInset, strokeInset);</span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:<span class="built_in">CGSizeMake</span>(radius, borderWidth)];</span><br><span class="line">path.lineWidth = borderWidth;</span><br><span class="line">[borderColor setStroke];</span><br><span class="line">[path stroke];</span><br><span class="line"><span class="built_in">UIImage</span> *result = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br></pre></td></tr></table></figure>
<h4 id="c-另一种特殊的离屏渲染：CPU-渲染"><a href="#c-另一种特殊的离屏渲染：CPU-渲染" class="headerlink" title="c. 另一种特殊的离屏渲染：CPU 渲染"></a>c. 另一种特殊的离屏渲染：CPU 渲染</h4><p>如果我们重写了 drawRect 方法，并且使用任何 Core Graphics 的技术进行了绘制操作，就涉及到了 CPU 渲染。整个渲染过程由 CPU 在 App 内同步地完成，渲染得到的 bitmap 最后再交由 GPU 用于显示。</p>
<p>由于 GPU 的浮点运算能力比 CPU 强，CPU 渲染的效率可能不如离屏渲染；但如果仅仅是实现一个简单的效果，直接使用 CPU 渲染的效率又可能比离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。</p>
<h4 id="d-离屏渲染检测工具：Instruments"><a href="#d-离屏渲染检测工具：Instruments" class="headerlink" title="d. 离屏渲染检测工具：Instruments"></a>d. 离屏渲染检测工具：Instruments</h4><p>Instruments 的 Core Animation 工具中有两个和离屏渲染相关的检查选项：</p>
<ol>
<li><p><strong>Color</strong> <strong>Offscreen-Rendered</strong> <strong>Yellow</strong><br>开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。</p>
</li>
<li><p><strong>Color</strong> <strong>Hits</strong> <strong>Green</strong> <strong>and</strong> <strong>Misses</strong> <strong>Red</strong><br>这一项是检查该场景下光栅化操作是否是一个好的选择，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。</p>
</li>
</ol>
<h4 id="e-iOS-版本上的优化"><a href="#e-iOS-版本上的优化" class="headerlink" title="e. iOS 版本上的优化"></a>e. iOS 版本上的优化</h4><p>iOS 9.0 之前 UIimageView 跟 UIButton 设置圆角都会触发离屏渲染</p>
<p>iOS 9.0 之后 UIButton 设置圆角会触发离屏渲染，而 UIImageView 里 png 图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。</p>
<p>这可能是苹果也意识到离屏渲染会产生性能问题，所以能不产生离屏渲染的地方苹果也就不用离屏渲染了。</p>
<h2 id="5-AsyncDisplayKit-思维方式"><a href="#5-AsyncDisplayKit-思维方式" class="headerlink" title="5. AsyncDisplayKit 思维方式"></a>5. AsyncDisplayKit 思维方式</h2><p>AsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库，其作者是 Scott Goodson (<a href="https://www.linkedin.com/in/iosengineer" target="_blank" rel="noopener">Linkedin</a>)</p>
<h3 id="ASDK-基本原理"><a href="#ASDK-基本原理" class="headerlink" title="ASDK 基本原理"></a>ASDK 基本原理</h3><p><img src="/img/img004.png" alt="image004"></p>
<p>ASDK 认为，阻塞主线程的任务，主要分为上面这三大类。文本和布局的计算、渲染、解码、绘制都可以通过各种方式异步执行，但 UIKit 和 Core Animation 相关操作必需在主线程进行。ASDK 的目标，就是尽量把这些任务从主线程挪走，而挪不走的，就尽量优化性能。</p>
<p>常见的 UIView 和 CALayer 的关系：View 持有 Layer 用于显示，View 中大部分显示属性实际是从 Layer 映射而来；Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。</p>
<p><img src="/img/img005.png" alt="image005"></p>
<p>ASDK 为此创建了 ASDisplayNode 类，包装了常见的视图属性（比如 frame/bounds/alpha/transform/backgroundColor/superNode/subNodes 等），然后它用 UIView -&gt; CALayer 相同的方式，实现了 ASNode -&gt; UIView 这样一个关系。</p>
<p><img src="/img/img006.png" alt="image006"></p>
<p>当不需要响应触摸事件时，ASDisplayNode 可以被设置为 layer backed，即 ASDisplayNode 充当了原来 UIView 的功能，节省了更多资源。</p>
<p>与 UIView 和 CALayer 不同，ASDisplayNode 是线程安全的，它可以在后台线程创建和修改。Node 刚创建时，并不会在内部新建 UIView 和 CALayer，直到第一次在主线程访问 view 或 layer 属性时，它才会在内部生成对应的对象。当它的属性（比如frame/transform）改变后，它并不会立刻同步到其持有的 view 或 layer 去，而是把被改变的属性保存到内部的一个中间变量，稍后在需要时，再通过某个机制一次性设置到内部的 view 或 layer。</p>
<p>通过模拟和封装 UIView/CALayer，开发者可以把代码中的 UIView 替换为 ASNode，很大的降低了开发和学习成本，同时能获得 ASDK 底层大量的性能优化。为了方便使用，ASDK 把大量常用控件都封装成了 ASNode 的子类，比如 Button、Control、Cell、Image、ImageView、Text、TableView、CollectionView 等。利用这些控件，开发者可以尽量避免直接使用 UIKit 相关控件，以获得更完整的性能提升。</p>
<h3 id="ASDK-的图层预合成"><a href="#ASDK-的图层预合成" class="headerlink" title="ASDK 的图层预合成"></a>ASDK 的图层预合成</h3><p><img src="/img/img007.png" alt="image007"><img src="/img/img008.png" alt="image008"></p>
<p>有时一个 layer 会包含很多 sub-layer，而这些 sub-layer 并不需要响应触摸事件，也不需要进行动画和位置调整。ASDK 为此实现了一个被称为 pre-composing 的技术，可以把这些 sub-layer 合成渲染为一张图片。开发时，ASNode 已经替代了 UIView 和 CALayer；直接使用各种 Node 控件并设置为 layer backed 后，ASNode 甚至可以通过预合成来避免创建内部的 UIView 和 CALayer。</p>
<p>通过这种方式，把一个大的层级，通过一个大的绘制方法绘制到一张图上，性能会获得很大提升。CPU 避免了创建 UIKit 对象的资源消耗，GPU 避免了多张 texture 合成和渲染的消耗，更少的 bitmap 也意味着更少的内存占用。</p>
<h3 id="ASDK-异步并发操作"><a href="#ASDK-异步并发操作" class="headerlink" title="ASDK 异步并发操作"></a>ASDK 异步并发操作</h3><p>充分利用多核的优势、并发执行任务对保持界面流畅有很大作用。ASDK 把布局计算、文本排版、图片/文本/图形渲染等操作都封装成较小的任务，并利用 GCD 异步并发执行。如果开发者使用了 ASNode 相关的控件，那么这些并发操作会自动在后台进行，无需进行过多配置。</p>
<h3 id="Runloop-任务分发"><a href="#Runloop-任务分发" class="headerlink" title="Runloop 任务分发"></a>Runloop 任务分发</h3><p><img src="/img/img009.png" alt="image009"></p>
<p>Runloop work distribution 是 ASDK 比较核心的一个技术，iOS 的显示系统是由<strong>垂直同步信号</strong>驱动的，<strong>垂直同步信号</strong>由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到<strong>垂直同步信号</strong>后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。</p>
<p>Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 Core Animation 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。</p>
<p>ASDK 在此处模拟了 Core Animation 的这个机制：所有针对 ASNode 的修改和提交，总有些任务是必需放入主线程执行的。当出现这种任务时，ASNode 会把任务用 ASAsyncTransaction(Group) 封装并提交到一个全局的容器去。ASDK 也在 RunLoop 中注册了一个 Observer，监视的事件和 Core Animation 一样，但优先级要低。当 RunLoop 进入休眠前、CA 处理完事件后，ASDK 就会执行该 loop 内提交的所有任务。</p>
<p>通过这种机制，ASDK 可以在合适的机会把异步、并发的操作同步到主线程去，并且能获得不错的性能。</p>
<h2 id="6-微博性能优化技巧"><a href="#6-微博性能优化技巧" class="headerlink" title="6. 微博性能优化技巧"></a>6. 微博性能优化技巧</h2><h3 id="预排版"><a href="#预排版" class="headerlink" title="预排版"></a>预排版</h3><p>当获取到 JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。</p>
<p>如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell/" target="_blank" rel="noopener">FDTemplateLayoutCell</a>。</p>
<h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><p>微博的头像在某次改版中换成了圆形，当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。</p>
<p>对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。如果用 layer 的圆角属性，查看 Instument 时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。</p>
<h3 id="异步绘制"><a href="#异步绘制" class="headerlink" title="异步绘制"></a>异步绘制</h3><p>我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：<a href="https://github.com/ibireme/YYAsyncLayer" target="_blank" rel="noopener">YYAsyncLayer</a>。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 <code>[layer setNeedDisplay]</code>）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个 <code>BOOL(^isCancelled)()</code> 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。</p>
<p>当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。</p>
<p>目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="noopener">VVeboTableViewDemo</a>。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。</p>
<h3 id="全局并发控制"><a href="#全局并发控制" class="headerlink" title="全局并发控制"></a>全局并发控制</h3><p>当用<strong>并发队列</strong>来执行大量绘制任务时，偶尔会遇到这种问题：大量的任务提交到后台队列时，某些任务会因为某些原因（此处是 CGFont 锁）被锁住导致线程休眠，或者被阻塞，<strong>并发队列</strong>随后会创建新的线程来执行其他任务。当这种情况变多时，或者 App 中使用了大量<strong>并发队列</strong>来执行较多任务时，App 在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管<strong>并发队列</strong>能控制线程的优先级，但当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。ASDK 有个 Feed 列表的 Demo：<a href="https://github.com/facebookarchive/AsyncDisplayKit/tree/master/examples/SocialAppLayout" target="_blank" rel="noopener">SocialAppLayout</a>，当列表内 Cell 过多，并且非常快速的滑动时，界面仍然会出现少量卡顿，我谨慎的猜测可能与这个问题有关。</p>
<p>使用<strong>并发队列</strong>时不可避免会遇到这种问题，但使用<strong>串行队列</strong>又不能充分利用多核 CPU 的资源。我写了一个简单的工具 <a href="https://github.com/ibireme/YYDispatchQueuePool" target="_blank" rel="noopener">YYDispatchQueuePool</a>，为不同优先级创建和 CPU 数量相同的 <strong>串行队列</strong>，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的<strong>并发队列</strong>中执行，这样尽量避免了过多线程导致的性能问题。</p>
<h3 id="更高效的异步图片加载"><a href="#更高效的异步图片加载" class="headerlink" title="更高效的异步图片加载"></a>更高效的异步图片加载</h3><p>SDWebImage 在这个 Demo 里仍然会产生少量性能问题，并且有些地方不能满足我的需求，所以我自己实现了一个性能更高的图片加载库。在显示简单的单张图片时，利用 UIView.layer.contents 就足够了，没必要使用 UIImageView 带来额外的资源消耗，为此我在 CALayer 上添加了 setImageWithURL 等方法。除此之外，我还把图片解码等操作通过 YYDispatchQueuePool 进行管理，控制了 App 总线程数量。</p>
<h3 id="其他可以改进的地方"><a href="#其他可以改进的地方" class="headerlink" title="其他可以改进的地方"></a>其他可以改进的地方</h3><p>上面这些优化做完后，微博 Demo 已经非常流畅了，但在我的设想中，仍然有一些进一步优化的技巧，但限于时间和精力我并没有实现，下面简单列一下：</p>
<ol>
<li><p>列表中有不少视觉元素并不需要触摸事件，这些元素可以用 ASDK 的图层合成技术预先绘制为一张图。</p>
</li>
<li><p>再进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView。</p>
</li>
<li><p>目前每个 Cell 的类型都是相同的，但显示的内容却各部一样，比如有的 Cell 有图片，有的 Cell 里是卡片。把 Cell 按类型划分，进一步减少 Cell 内不必要的视图对象和操作，应该能有一些效果。</p>
</li>
<li><p>把需要放到主线程执行的任务划分为足够小的块，并通过 Runloop 来进行调度，在每个 Loop 里判断下一次 VSync 的时间，并在下次 VSync 到来前，把当前未执行完的任务延迟到下一个机会去。这个只是我的一个设想，并不一定能实现或起作用。</p>
</li>
</ol>
<h2 id="7-如何评测界面的流畅度"><a href="#7-如何评测界面的流畅度" class="headerlink" title="7. 如何评测界面的流畅度"></a>7. 如何评测界面的流畅度</h2><p>最后还是要提一下，“过早的优化是万恶之源”，在需求未定，性能问题不明显时，没必要尝试做优化，而要尽量正确的实现功能。</p>
<p>如果你需要一个明确的 FPS 指示器，可以尝试一下 <a href="https://github.com/kconner/KMCGeigerCounter" target="_blank" rel="noopener">KMCGeigerCounter</a>。对于 CPU 的卡顿，它可以通过内置的 CADisplayLink 检测出来；对于 GPU 带来的卡顿，它用了一个 1×1 的 SKView 来进行监视。这个项目有两个小问题：SKView 虽然能监视到 GPU 的卡顿，但引入 SKView 本身就会对 CPU/GPU 带来额外的一点的资源消耗；这个项目在 iOS 9 下有一些兼容问题，需要稍作调整。</p>
<p>我自己也写了个简单的 FPS 指示器：<a href="https://github.com/ibireme/YYText/blob/master/Demo/YYTextDemo/YYFPSLabel.m" target="_blank" rel="noopener">FPSLabel</a> 只有几十行代码，仅用到了 CADisplayLink 来监视 CPU 的卡顿问题。虽然不如上面这个工具完善，但日常使用没有太大问题。</p>
<p>最后，用 Instuments 的 GPU Driver 预设，能够实时查看到 CPU 和 GPU 的资源消耗。在这个预设内，你能查看到几乎所有与显示有关的数据，比如 Texture 数量、CA 提交的频率、GPU 消耗等，在定位界面卡顿的问题时，这是最好的工具。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/06/【读书笔记】《Objective-C 高级编程：iOS 与 OS X 多线程和内存管理》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mayan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mayan`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/06/【读书笔记】《Objective-C 高级编程：iOS 与 OS X 多线程和内存管理》/" itemprop="url">【读书笔记】《Objective-C 高级编程：iOS 与 OS X 多线程和内存管理》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T10:31:22+08:00">
                2018-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/06/【读书笔记】《Objective-C 高级编程：iOS 与 OS X 多线程和内存管理》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/02/06/【读书笔记】《Objective-C 高级编程：iOS 与 OS X 多线程和内存管理》/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：坂本一树 / 古本智彦 </p>
<p>出版日期：2013-6-1</p>
<p>豆瓣地址：<a href="https://book.douban.com/subject/24720270/" target="_blank" rel="noopener">https://book.douban.com/subject/24720270/</a></p>
</blockquote>
<h2 id="1-引用计数内部实现"><a href="#1-引用计数内部实现" class="headerlink" title="1. 引用计数内部实现"></a>1. 引用计数内部实现</h2><p>查看引用计数相关源代码，可以看出每次都会取得 <code>CFBasicHashRef</code> 进行操作，由此可知苹果采用散列表（引用计数表）来管理引用计数。</p>
<blockquote>
<p>散列表（Hash table，也叫哈希表），是根据 key 而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这就加快了查找速度。这个映射函数称作散列函数，存放记录的数组称作散列表。</p>
<p>一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 x 到首字母 F(x) 的一个函数关系），在首字母为 W 的表中查找<code>王</code>姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，<code>取首字母</code>是这个例子中散列函数的函数法则 F()，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。</p>
</blockquote>
<p>引用计数表各记录中存有内存块地址，可以各个记录追溯到各对象的内存块。这一特性在调试时有着重要的作用：即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各内存块的位置：</p>
<p><img src="/img/img029.png" alt="image029"></p>
<p>另外，在利用工具检测内存泄漏时，引用计数表的各记录也有助于检测各对象的持有者是否存在。</p>
<h2 id="2-Block-的本质"><a href="#2-Block-的本质" class="headerlink" title="2. Block 的本质"></a>2. Block 的本质</h2><h3 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">"Hello World."</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用终端 <code>$ clang -rewrite-objc main.m</code> 将 Objective-C 代码转化成 C++ 源代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello World."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; </span><br><span class="line">  <span class="number">0</span>, </span><br><span class="line">  <span class="keyword">sizeof</span>(struct __main_block_impl_0)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = </span><br><span class="line">      ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0(</span><br><span class="line">        (<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看 <code>main</code> 中构造函数的调用，因为转换较多，看起来不是很清楚，所以我们去掉转换的部分，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> <span class="title">tmp</span> = __<span class="title">main_block_impl_0</span>(__<span class="title">main_block_func_0</span>, &amp;__<span class="title">main_block_desc_0_DATA</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> *<span class="title">blk</span> = &amp;<span class="title">tmp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就容易理解了，该源代码中的 block 就是 <code>__main_block_impl_0</code> 结构体类型的局部变量，即栈上生成的 <code>__main_block_impl_0</code> 结构体实例。再来看 block 调用部分，这就是简单地使用函数指针调用函数。由 block 语法转换的 <code>__main_block_func_0</code> 函数指针被赋值成员变量 <code>FuncPtr</code> 中，在调用该函数的源代码中可以看出 block 正是作为参数进行了传递。所以 block 的本质即为 Objective-C 的对象。</p>
<h3 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">"%d, %d"</span>, num1, num2);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用终端 <code>$ clang -rewrite-objc main.m</code> 将 Objective-C 代码转化成 C++ 源代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num1;</span><br><span class="line">  <span class="keyword">int</span> num2;</span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _num1, <span class="keyword">int</span> _num2, <span class="keyword">int</span> flags=<span class="number">0</span>) : num1(_num1), num2(_num2) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> num1 = __cself-&gt;num1; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> num2 = __cself-&gt;num2; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d, %d"</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123;</span><br><span class="line">  <span class="number">0</span>, </span><br><span class="line">  <span class="keyword">sizeof</span>(struct __main_block_impl_0)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = </span><br><span class="line">      ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0(</span><br><span class="line">        (<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, num1, num2)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上一个例子相比，block 语法表达式中使用的局部变量被作为成员变量追加到了 <code>__main_block_impl_0</code> 结构体中。总的来说，所谓截取局部变量值意味着在执行 block 语法时，block 语法表达式所使用的自动变量值被保存到 block 自身中。</p>
<h3 id="例-3"><a href="#例-3" class="headerlink" title="例 3"></a>例 3</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    __block <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    __block <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        num1 = <span class="number">100</span>;</span><br><span class="line">        num2 = <span class="number">200</span>;</span><br><span class="line">        printf(<span class="string">"%d, %d"</span>, num1, num2);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用终端 <code>$ clang -rewrite-objc main.m</code> 将 Objective-C 代码转化成 C++ 源代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_num1_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_num1_0 *__forwarding;</span><br><span class="line">  <span class="keyword">int</span> __flags;</span><br><span class="line">  <span class="keyword">int</span> __size;</span><br><span class="line">  <span class="keyword">int</span> num1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_num2_1</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_num2_1 *__forwarding;</span><br><span class="line">  <span class="keyword">int</span> __flags;</span><br><span class="line">  <span class="keyword">int</span> __size;</span><br><span class="line">  <span class="keyword">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line"></span><br><span class="line">  __Block_byref_num1_0 *num1; <span class="comment">// by ref</span></span><br><span class="line">  __Block_byref_num2_1 *num2; <span class="comment">// by ref</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_num1_0 *_num1, __Block_byref_num2_1 *_num2, <span class="keyword">int</span> flags=<span class="number">0</span>) : num1(_num1-&gt;__forwarding), num2(_num2-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_num1_0 *num1 = __cself-&gt;num1; <span class="comment">// bound by ref</span></span><br><span class="line">  __Block_byref_num2_1 *num2 = __cself-&gt;num2; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">  (num1-&gt;__forwarding-&gt;num1) = <span class="number">100</span>;</span><br><span class="line">  (num2-&gt;__forwarding-&gt;num2) = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d, %d"</span>, (num1-&gt;__forwarding-&gt;num1), (num2-&gt;__forwarding-&gt;num2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign(</span><br><span class="line">      (<span class="keyword">void</span>*)&amp;dst-&gt;num1, </span><br><span class="line">      (<span class="keyword">void</span>*)src-&gt;num1, </span><br><span class="line">      <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">    _Block_object_assign(</span><br><span class="line">      (<span class="keyword">void</span>*)&amp;dst-&gt;num2, </span><br><span class="line">      (<span class="keyword">void</span>*)src-&gt;num2,</span><br><span class="line">       <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">  _Block_object_dispose(</span><br><span class="line">    (<span class="keyword">void</span>*)src-&gt;num1,</span><br><span class="line">    <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">  _Block_object_dispose(</span><br><span class="line">    (<span class="keyword">void</span>*)src-&gt;num2, </span><br><span class="line">    <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; </span><br><span class="line">  <span class="number">0</span>, </span><br><span class="line">  <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_num1_0 num1 = &#123;</span><br><span class="line">      (<span class="keyword">void</span>*)<span class="number">0</span>,</span><br><span class="line">      (__Block_byref_num1_0 *)&amp;num1, </span><br><span class="line">      <span class="number">0</span>, </span><br><span class="line">      <span class="keyword">sizeof</span>(__Block_byref_num1_0), </span><br><span class="line">      <span class="number">10</span></span><br><span class="line">    &#125;;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_num2_1 num2 = &#123;</span><br><span class="line">      (<span class="keyword">void</span>*)<span class="number">0</span>,</span><br><span class="line">      (__Block_byref_num2_1 *)&amp;num2,</span><br><span class="line">       <span class="number">0</span>, </span><br><span class="line">       <span class="keyword">sizeof</span>(__Block_byref_num2_1), </span><br><span class="line">       <span class="number">20</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_num1_0 *)&amp;num1, (__Block_byref_num2_1 *)&amp;num2, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，添加了 <code>__block</code> 的局部变量竟然变成了结构体实例，栈上生成该结构体的实例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_num1_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_num1_0 *__forwarding;</span><br><span class="line">  <span class="keyword">int</span> __flags;</span><br><span class="line">  <span class="keyword">int</span> __size;</span><br><span class="line">  <span class="keyword">int</span> num1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> __Block_byref_num2_1 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_num2_1 *__forwarding;</span><br><span class="line">  <span class="keyword">int</span> __flags;</span><br><span class="line">  <span class="keyword">int</span> __size;</span><br><span class="line">  <span class="keyword">int</span> num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-Block-存储域"><a href="#3-Block-存储域" class="headerlink" title="3. Block 存储域"></a>3. Block 存储域</h2><p>通过前面说明可知，block 转换为 block 结构体类型的局部变量，即栈上生成的该结构体的实例。通过之前的说明可知 block 也是 Objective-C 对象，该 block 的类为 <code>_NSConcreteStackBlock</code>，具体整理如下：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>设置对象的存储域</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域（.data 区）</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
</tr>
</tbody>
</table>
<h5 id="NSConcreteStackBlock-类型："><a href="#NSConcreteStackBlock-类型：" class="headerlink" title="_NSConcreteStackBlock 类型："></a>_NSConcreteStackBlock 类型：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NSConcreteGlobalBlock-类型："><a href="#NSConcreteGlobalBlock-类型：" class="headerlink" title="_NSConcreteGlobalBlock 类型："></a>_NSConcreteGlobalBlock 类型：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    printf(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NSConcreteMallocBlock-类型："><a href="#NSConcreteMallocBlock-类型：" class="headerlink" title="_NSConcreteMallocBlock 类型："></a>_NSConcreteMallocBlock 类型：</h5><p>实际上，大多数情形下编译器会恰当进行判断，自动生成将 block 从栈上复制到堆上的代码</p>
<h2 id="4-GCD-几种常用方法"><a href="#4-GCD-几种常用方法" class="headerlink" title="4. GCD 几种常用方法"></a>4. GCD 几种常用方法</h2><h3 id="4-1-dispatch-get-global-queue"><a href="#4-1-dispatch-get-global-queue" class="headerlink" title="4.1. dispatch_get_global_queue"></a>4.1. dispatch_get_global_queue</h3><p>我们没有必要通过 <code>dispatch_queue_create</code> 函数逐个生成队列，只要获取系统标准提供的队列 <code>Global Dispatch Queue</code> 即可，获取方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Global Dispatch Queue（高优先级）的获取方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> hightQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Global Dispatch Queue（默认优先级）的获取方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Global Dispatch Queue（低优先级）的获取方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> lowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Global Dispatch Queue（后台优先级）的获取方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="meta">### 4.2. dispatch\_set\_target\_queue</span></span><br><span class="line"></span><br><span class="line">第一个参数为要设置优先级的 queue，第二个参数是参照物，即将第一个 queue 的优先级和第二个 queue 的优先级设置一样：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</span><br><span class="line">dispatch_set_target_queue(queue, backgroundQueue);</span><br></pre></td></tr></table></figure>
<p>还有一种使用场景是，使用 <code>dispatch_set_target_queue</code> 将多个串行的 <code>queue</code> 指定到了同一目标，那么多个串行 <code>queue</code> 在目标 <code>queue</code> 上就是同步执行了，不再是并行执行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建目标队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="string">"target.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.创建 3 个串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"queue.1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"queue.2"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue3 = dispatch_queue_create(<span class="string">"queue.3"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3.将 3 个串行队列分别添加到目标队列</span></span><br><span class="line">dispatch_set_target_queue(queue1, targetQueue);</span><br><span class="line">dispatch_set_target_queue(queue2, targetQueue);</span><br><span class="line">dispatch_set_target_queue(queue3, targetQueue);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1 in"</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.</span>f];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1 out"</span>);</span><br><span class="line">&#125;);    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2 in"</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2 out"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue3, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3 in"</span>);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3 out"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">打印结果为：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">04.495511</span>+<span class="number">0800</span> Test[<span class="number">9744</span>:<span class="number">161033</span>] <span class="number">1</span> <span class="keyword">in</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">07.500984</span>+<span class="number">0800</span> Test[<span class="number">9744</span>:<span class="number">161033</span>] <span class="number">1</span> <span class="keyword">out</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">07.501277</span>+<span class="number">0800</span> Test[<span class="number">9744</span>:<span class="number">161033</span>] <span class="number">2</span> <span class="keyword">in</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">09.504112</span>+<span class="number">0800</span> Test[<span class="number">9744</span>:<span class="number">161033</span>] <span class="number">2</span> <span class="keyword">out</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">09.504318</span>+<span class="number">0800</span> Test[<span class="number">9744</span>:<span class="number">161033</span>] <span class="number">3</span> <span class="keyword">in</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">10</span>:<span class="number">51</span>:<span class="number">10.509577</span>+<span class="number">0800</span> Test[<span class="number">9744</span>:<span class="number">161033</span>] <span class="number">3</span> <span class="keyword">out</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-dispatch-apply"><a href="#4-3-dispatch-apply" class="headerlink" title="4.3. dispatch_apply"></a>4.3. dispatch_apply</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zu"</span>, index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"done"</span>);</span><br></pre></td></tr></table></figure>
<p>如上代码执行结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.807653</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300472</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.807653</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300507</span>] <span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.807653</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300508</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.807828</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300472</span>] <span class="number">4</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.807653</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300506</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.807832</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300507</span>] <span class="number">5</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.807845</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300508</span>] <span class="number">6</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.807948</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300472</span>] <span class="number">7</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.808007</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300506</span>] <span class="number">8</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.808077</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300507</span>] <span class="number">9</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">35.808545</span>+<span class="number">0800</span> Test[<span class="number">10129</span>:<span class="number">300472</span>] done</span><br></pre></td></tr></table></figure>
<p>在多线程中执行各个处理的执行时间不定，但是输出结果中最后的 done 必定在最后的位置上，这是因为 <code>dispatch_apply</code> 函数会等待全部处理执行结束。例如要对 <code>NSArray</code> 类对象的所有元素执行处理时，不必一个一个编写 for 循环部分：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = @[<span class="string">@"第一个元素"</span>,</span><br><span class="line">                 <span class="string">@"第二个元素"</span>,</span><br><span class="line">                 <span class="string">@"第三个元素"</span>,</span><br><span class="line">                 <span class="string">@"第四个元素"</span>,</span><br><span class="line">                 <span class="string">@"第五个元素"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dispatch_apply(arr.count, queue, ^(size_t index) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zu : %@"</span>, index, arr[index]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"done"</span>);</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">35</span>:<span class="number">09.766620</span>+<span class="number">0800</span> Test[<span class="number">10156</span>:<span class="number">311140</span>] <span class="number">0</span> : 第一个元素</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">35</span>:<span class="number">09.766621</span>+<span class="number">0800</span> Test[<span class="number">10156</span>:<span class="number">311222</span>] <span class="number">1</span> : 第二个元素</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">35</span>:<span class="number">09.766622</span>+<span class="number">0800</span> Test[<span class="number">10156</span>:<span class="number">311223</span>] <span class="number">3</span> : 第四个元素</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">35</span>:<span class="number">09.766632</span>+<span class="number">0800</span> Test[<span class="number">10156</span>:<span class="number">311224</span>] <span class="number">2</span> : 第三个元素</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">35</span>:<span class="number">09.766840</span>+<span class="number">0800</span> Test[<span class="number">10156</span>:<span class="number">311222</span>] <span class="number">4</span> : 第五个元素</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">14</span>:<span class="number">35</span>:<span class="number">09.766958</span>+<span class="number">0800</span> Test[<span class="number">10156</span>:<span class="number">311140</span>] done</span><br></pre></td></tr></table></figure>
<h3 id="4-4-dispatch-suspend-dispatch-resume"><a href="#4-4-dispatch-suspend-dispatch-resume" class="headerlink" title="4.4. dispatch_suspend / dispatch_resume"></a>4.4. dispatch_suspend / dispatch_resume</h3><p><code>dispatch_suspend</code> 和 <code>dispatch_resume</code> 提供了挂起、恢复队列的功能，简单来说，就是可以暂停、恢复队列上的任务。但是这里的挂起，并不能保证可以立即停止队列上正在运行的 <code>block</code>，未执行的 <code>block</code> 会被挂起。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"挂起队列之前，打印后延迟 5 秒"</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"挂起队列之前，延迟 5 秒后的打印"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"挂起队列之前，打印后延迟 5 秒，再一次"</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"挂起队列之前，延迟 5 秒后的打印，再一次"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"打印之后延迟 1 秒"</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"挂起队列"</span>);</span><br><span class="line">dispatch_suspend(queue);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"挂起队列之后，打印后延迟 10 秒"</span>);</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"恢复队列"</span>);</span><br><span class="line">dispatch_resume(queue);</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">15.817281</span>+<span class="number">0800</span> Test[<span class="number">10265</span>:<span class="number">348250</span>] 打印之后延迟 <span class="number">1</span> 秒</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">15.817281</span>+<span class="number">0800</span> Test[<span class="number">10265</span>:<span class="number">348322</span>] 挂起队列之前，打印后延迟 <span class="number">5</span> 秒</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">16.818663</span>+<span class="number">0800</span> Test[<span class="number">10265</span>:<span class="number">348250</span>] 挂起队列</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">16.818853</span>+<span class="number">0800</span> Test[<span class="number">10265</span>:<span class="number">348250</span>] 挂起队列之后，打印后延迟 <span class="number">10</span> 秒</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">20.821085</span>+<span class="number">0800</span> Test[<span class="number">10265</span>:<span class="number">348322</span>] 挂起队列之前，延迟 <span class="number">5</span> 秒后的打印</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">26.820438</span>+<span class="number">0800</span> Test[<span class="number">10265</span>:<span class="number">348250</span>] 恢复队列</span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-02</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">31.826083</span>+<span class="number">0800</span> Test[<span class="number">10265</span>:<span class="number">348327</span>] 挂起队列之前，延迟 <span class="number">5</span> 秒后的打印，再一次</span><br></pre></td></tr></table></figure>
<h3 id="4-5-dispatch-semaphore-wait-dispatch-semaphore-signal"><a href="#4-5-dispatch-semaphore-wait-dispatch-semaphore-signal" class="headerlink" title="4.5. dispatch_semaphore_wait / dispatch_semaphore_signal"></a>4.5. dispatch_semaphore_wait / dispatch_semaphore_signal</h3><p>当并行执行的处理更新数据时，会产生数据不一致的情况，有时应该程序还会异常结束。如下例子，不考虑顺序，将所有数据添加到 <code>NSMutableArray</code> 中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        [arr addObject:@(i)];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"已经添加：%d"</span>, i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印途中崩溃停止，所以此时我们应该使用 <code>Dispatch Semaphore</code> 。<code>Dispatch Semaphore</code> 是持有计数的信号，类似于过马路时常用的手旗，可以通过时举起手旗，不可通过时放下手旗。<code>Dispatch Semaphore</code> 使用计数来实现该功能，计数为 0 时等待，计数为 1 或者大于 1 时，减去 1 而不等待。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 一直等待，直到 semaphore 的计数值达到大于等于 1</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [arr addObject:@(i)];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"已经添加：%d"</span>, i);</span><br><span class="line">        <span class="comment">// 通过该函数将 semaphore 计数值加 1</span></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-Dispatch-I-O-Dispatch-Data"><a href="#4-6-Dispatch-I-O-Dispatch-Data" class="headerlink" title="4.6. Dispatch I/O / Dispatch Data"></a>4.6. Dispatch I/O / Dispatch Data</h3><p>在读取较大的文件时，如果将文件分成合适的大小并使用并行队列读取的话,应该会比一般的读取速度快不少。 在 GCD 当中能实现这一功能的就是 Dispatch I/O 和 Dispatch Data。具体代码实现参照 Apple System Log API 里的<a href="https://opensource.apple.com/source/Libc/Libc-763.11/gen/asl.c" target="_blank" rel="noopener">源代码</a>。</p>
<h2 id="5-GCD-的实现"><a href="#5-GCD-的实现" class="headerlink" title="5. GCD 的实现"></a>5. GCD 的实现</h2><p>涉及到低层的太多，总结不出来，只能贴上<a href="https://github.com/mayan29/BlogCode/tree/master/【读书笔记】《Objective-C%20高级编程：iOS%20与%20OS%20X%20多线程和内存管理》" target="_blank" rel="noopener">原文</a>了。。。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>去年仅阅读了第一篇章，今年花了 4、5 天时间把整本书全部阅读完成。感觉讲的挺不错的，就是翻译的有点不通顺，废话也略多。感觉比较有用的地方是，block 编译成 c++ 代码后的解析，对 block 低层实现原理豁然开朗。</p>
<p>本以为年前没有迭代任务，可以慢慢地看书了，突然要在年前启动一个新项目，有点浮躁了，后面的 GCD 低层看不下去了，心态崩了[衰]</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mayan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mayan`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/" itemprop="url">【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-05T16:36:42+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：Matt Galloway</p>
<p>出版日期：2014-1</p>
<p>豆瓣地址：<a href="https://book.douban.com/subject/25829244/" target="_blank" rel="noopener">https://book.douban.com/subject/25829244/</a></p>
</blockquote>
<h2 id="1-了解-Objective-C-语言"><a href="#1-了解-Objective-C-语言" class="headerlink" title="1. 了解 Objective-C 语言"></a>1. 了解 Objective-C 语言</h2><p>OC 使用<code>消息结构</code>（messaging structure）而不是<code>函数调用</code>（function calling），写法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">Object *obj = [Object new];</span><br><span class="line">[obj performWith: parameter1 and: parameter2];</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line">Object *obj = <span class="keyword">new</span> Object;</span><br><span class="line">obj-&gt;perform(parameter1, parameter2);</span><br></pre></td></tr></table></figure>
<p>使用消息结构的语言，运行时执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。如果调用的函数是多态的，那么在运行时就要按照<code>虚方法表</code>（virtual table）来查出到底应该执行哪个函数实现。而消息结构的语言，不论是否多态，总是在运行时才会去查找所要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，其过程叫做<code>动态绑定</code>（dynamic binding）。</p>
<p>Objective-C 的重要工作都由 runtime 组件而非编译器来完成，所需的全部数据结构和函数都在 runtime 组件里面，runtime 组件含有全部内存管理方法。runtime 本质上就是一种与开发者编写的代码相链接的<code>动态库</code>（dynamic library），其代码能把开发者编写的所有程序粘合起来。</p>
<h2 id="2-在类的头文件中尽量少引入其他头文件"><a href="#2-在类的头文件中尽量少引入其他头文件" class="headerlink" title="2. 在类的头文件中尽量少引入其他头文件"></a>2. 在类的头文件中尽量少引入其他头文件</h2><p>与 C 和 C++ 一样，OC 也使用<code>头文件</code>（header file）和<code>实现文件</code>（implementation file）来区隔代码。用 OC 编写的任何类几乎都需要引入 <code>Foundation.h</code>，如果包含 UI 控件，需要引入 <code>UIKit.h</code></p>
<p>一般来说，应在某个类的头文件中使用<code>前向声明</code>（forward declaring）来提及别的类，这样做可以尽量降低类之间的耦合。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">MYPerson</span>;</span></span><br></pre></td></tr></table></figure>
<p>循环引用（chicken-and-egg situation）：如果在各自头文件中引入对方的头文件，当解析其中一个头文件时，编译器会发现它引入了另一个头文件，而那个头文件又回过头来引用第一个头文件。使用 #import 而非 #include 指令虽然不会导致死循环，但是却意味着两个类里有一个无法被正确编译。</p>
<h2 id="3-多用字面量语法，少用与之等价的方法"><a href="#3-多用字面量语法，少用与之等价的方法" class="headerlink" title="3.多用字面量语法，少用与之等价的方法"></a>3.多用字面量语法，少用与之等价的方法</h2><p>使用<code>字面量语法</code>（literal syntax）的好处是可以缩减源代码长度，使其更为易读。其本质为一种<code>语法糖</code>（syntactic sugar），以数组为例，其效果等于是先创建一个数组，然后把方括号里的所有对象都加到这个数组中。但是数组元素中不能有 nil，因为 arrayWithObjects: 方法会依次处理各个参数，直到发现 nil 为止，如果中间元素是 nil，该方法会提前结束。这个问题同样适用于字典。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h2 id="4-多用类型常量，少用-define-预处理指令"><a href="#4-多用类型常量，少用-define-预处理指令" class="headerlink" title="4.多用类型常量，少用 #define 预处理指令"></a>4.多用类型常量，少用 #define 预处理指令</h2><p>比如想把播放动画的时间提取为常量，使用预处理指令，也就是宏定义可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ANIMATION_DURATION 0.3</span></span><br></pre></td></tr></table></figure>
<p>上面的宏定义的缺点是，这样定义出来的常量没有类型信息，此外会把碰到的所有 ANIMATION_DURATION 一律替换成 0.3</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<p>上面的方式定义的常量包含类型信息，其好处是清楚的描述了常量的含义。需要注意的是，如果常量局限于 .m 文件中，则在前面加字母 k；若常量在类之外可见，通常以类名为前缀，比如 MYViewAnimationDuration。</p>
<p>static 作用：假如声明此变量时不加 static，则编译器会为它创建一个外部符号，此时若是另一个实现文件也声明了同名变量，那么编译器会报错。</p>
<p>如果需要对外公开某个常量，可以声明为一个外界可见的常值变量，外界无需知道实际常量值，只需知道常量名称即可，此类常量需放在<code>全局符号表</code>（global symbol table）中，如下定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> MYStringConstant;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> MYStringConstant = <span class="string">@"VALUE"</span>;</span><br></pre></td></tr></table></figure>
<p>编译器看到头文件中的 extern 关键字，无需查看其定义，即允许代码使用此常量。因为它知道，当链接成二进制文件之后，肯定能找到这个常量。</p>
<p>此类常量必须定义，并且只能定义一次，由实现文件生成目标文件时，编译器会在<code>数据段</code>（data section）为字符串分配存储空间。链接器会把此目标文件与其他目标文件相链接，以生成最终的二进制文件。凡是用到 MYStringConstant 这个全局符号的地方，链接器都能将其解析。</p>
<p>前例中的动画播放时长对外公布，可以这样声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> MYViewAnimationDuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> MYViewAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<h2 id="5-用枚举表示状态、选项、状态码"><a href="#5-用枚举表示状态、选项、状态码" class="headerlink" title="5. 用枚举表示状态、选项、状态码"></a>5. 用枚举表示状态、选项、状态码</h2><p>C++11 标准修订了枚举的某些特性，其中一项改动就是：可以指明用何种<code>底层数据类型</code>（underlying type）来保存枚举类型的变量，这样做的好处是，可以向前声明枚举变量了。若不指定底层数据类型，编译器不清楚底层数据类型的大小，所以在用到此枚举类型时，就不知道究竟该给变量分配多少空间。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> MYConnectionState : <span class="built_in">NSUInteger</span> &#123;</span><br><span class="line">    MYConnectionStateDisconnected,</span><br><span class="line">    MYConnectionStateConnecting,</span><br><span class="line">    MYConnectionStateConnected</span><br><span class="line">&#125; MYConnectionState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, MYConnectionState) &#123;</span><br><span class="line">    MYConnectionStateDisconnected,</span><br><span class="line">    MYConnectionStateConnecting,</span><br><span class="line">    MYConnectionStateConnected</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MYConnectionState state = MYConnectionStateConnecting;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> MYConnectionState : <span class="built_in">NSUInteger</span> &#123;</span><br><span class="line">    MYConnectionStateDisconnected = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    MYConnectionStateConnecting   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    MYConnectionStateConnected    = <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line">&#125; MYConnectionState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, MYConnectionState) &#123;</span><br><span class="line">    MYConnectionStateDisconnected = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    MYConnectionStateConnecting   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    MYConnectionStateConnected    = <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MYConnectionState state = MYConnectionStateDisconnected | MYConnectionStateConnecting;</span><br></pre></td></tr></table></figure>
<h2 id="6-理解属性这一概念"><a href="#6-理解属性这一概念" class="headerlink" title="6. 理解属性这一概念"></a>6. 理解属性这一概念</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MYPerson</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSString</span> *_firstName;</span><br><span class="line">	<span class="built_in">NSString</span> *_lastName;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>以上写法一般是 Java 和 C++ 的写法，而 Objective-C 代码却很少这么做。这种写法的问题是：对象布局在<code>编译期</code>（compile time）就已经固定了。只要碰到访问 <code>_fistName</code> 变量的代码，编译器就把其替换为<code>偏移量</code>（offset），这个偏移量是<code>硬编码</code>（hardcode），表示该变量距离存放对象的内存区域的起始地址有多远。这样做目前来看没有问题，但是如果又加了一个实例变量，那就麻烦了。比如在 <code>_firstName</code> 之前又多了一个实例变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MYPerson</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSString</span> *_dateOfBirth;</span><br><span class="line">	<span class="built_in">NSString</span> *_firstName;</span><br><span class="line">	<span class="built_in">NSString</span> *_lastName;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>原来表示 <code>_firstName</code> 的偏移量现在却指向 <code>_dataOfBirth</code>，把偏移量硬编码于其中的那些代码都会读取到错误的值</p>
<p><img src="/img/img025.png" alt="image025"></p>
<p>如果代码使用了编译期间计算出来的偏移量，那么在修改类定义之后必须重新编译，否则就会出错。</p>
<p>Objective-C 的做法是，把实例变量当做一种存储偏移量所用的<code>特殊变量</code>（special variable），交由<code>类对象</code>（class object）保管，偏移量会在运行期查找，如果类的定义变了，那么存储的偏移量也就变了，所以总能使用正确的偏移量，甚至可以在运行期向类中新增实例变量。</p>
<p>这个问题还有一种解决方法，就是尽量不要直接访问实例变量，应该通过存取方法来做。Objective-C 这门语言就是根据名称自动创建出存取方法，也就是 @property 语法。</p>
<h3 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>所有属性都声明为 nonatomic 是因为：在 iOS 中使用同步锁开销较大，一般不要求属性必须是原子的，因为这并不能保证线程安全，若要实现线程安全，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写改值，那么即便将属性声明为 atomic 也还是会读到不同的属性值。</p>
<h4 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h4><p>readwrite / readonly</p>
<h4 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h4><ul>
<li><p>assign：纯量类型（scalar type），简单赋值操作</p>
</li>
<li><p>strong：拥有关系（owning relationship），为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</p>
</li>
<li><p>weak：非拥有关系（nonowning relationship），为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，类似 assign</p>
</li>
<li><p>copy：拷贝（copy），当属性类型为 NSString* 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例，此类是 NSString 的子类，如果不拷贝字符串，那么设置完属性后，字符串的值就会在对象不知情的情况被修改</p>
</li>
</ul>
<h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>getter=<name> / setter=<name></name></name></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isOn) <span class="built_in">BOOL</span> on;</span><br></pre></td></tr></table></figure>
<h2 id="7-在对象内部读写是否使用实例变量"><a href="#7-在对象内部读写是否使用实例变量" class="headerlink" title="7. 在对象内部读写是否使用实例变量"></a>7. 在对象内部读写是否使用实例变量</h2><p>直接访问实例变量和通过属性访问区别如下：</p>
<ul>
<li><p>直接访问实例变量的速度更快，由于不经过 OC 的<code>方法派发</code>（method dispatch），编译器所生成的代码会直接访问保存对象实例变量的那块内存；</p>
</li>
<li><p>直接访问实例变量不会调用设置方法，比如在 ARC 下直接访问一个声明为 copy 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值；</p>
</li>
<li><p>直接访问实例变量不会触发 KVO 通知；</p>
</li>
<li><p>通过属性访问有助于排查与之相关的错误</p>
</li>
</ul>
<p>总结为：在对象内部读取数据时，直接通过实例变量来读；写入数据时，通过属性 set 方法来写。</p>
<h2 id="8-以类族模式隐藏实现细节"><a href="#8-以类族模式隐藏实现细节" class="headerlink" title="8. 以类族模式隐藏实现细节"></a>8. 以类族模式隐藏实现细节</h2><p><code>类族</code>（class cluster）是一种很有用的模式，可以隐藏<code>抽象基类</code>（abstract base class）背后的实现细节，例如 UIButton 的类方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIButton</span> *)buttonWithType:(<span class="built_in">UIButtonType</span>)type;</span><br></pre></td></tr></table></figure>
<p>该方法所返回的对象，其类型取决于传入的按钮类型，然而，不管返回什么类型的对象，他们都继承同一个基类：UIButton，这么做的意义是，UIButton 的使用者无须关心创建出来的按钮具体属于哪个子类，只需明白如何创建按钮，设置属性即可。</p>
<p>举一个例子，创建一个 MYPerson 抽象类，MYStudent、MYTeacher、MYWorker 每一个子类都继承 MYPerson</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MYPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, MYPersonType) &#123;</span><br><span class="line"></span><br><span class="line">    MYPersonTypeStudent,</span><br><span class="line">    MYPersonTypeTeacher,</span><br><span class="line">    MYPersonTypeWorker,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)personWithType:(MYPersonType)type;</span><br><span class="line">- (<span class="keyword">void</span>)introduceMyself;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MYPerson.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MYStudent.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MYTeacher.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MYWorker.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MYPerson</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)personWithType:(MYPersonType)type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> MYPersonTypeStudent:</span><br><span class="line">            <span class="keyword">return</span> [[MYStudent alloc] init];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MYPersonTypeTeacher:</span><br><span class="line">            <span class="keyword">return</span> [[MYTeacher alloc] init];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MYPersonTypeWorker:</span><br><span class="line">            <span class="keyword">return</span> [[MYWorker alloc] init];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)introduceMyself</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>方法调用，打印结果为 MYWorker</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MYPerson *person = [MYPerson personWithType:MYPersonTypeWorker];</span><br><span class="line">[person introduceMyself];</span><br></pre></td></tr></table></figure>
<h2 id="9-理解-objc-msgSend-的作用"><a href="#9-理解-objc-msgSend-的作用" class="headerlink" title="9. 理解 objc_msgSend 的作用"></a>9. 理解 objc_msgSend 的作用</h2><h3 id="9-1-基本消息传递"><a href="#9-1-基本消息传递" class="headerlink" title="9.1 基本消息传递"></a>9.1 基本消息传递</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure>
<p>上面所示方法中，someObject 叫做<code>接受者</code>（receiver），messageName 叫做<code>选择子</code>（selector），选择子和参数合起来称为<code>消息</code>（message）。编译器将其转换为一条 C 语言函数调用，所调函数乃是消息传递机制中的核心函数，叫做 <code>objc_msgSend</code>，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:), parameter);</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSend</code> 函数依据<code>接受者</code>和<code>选择子</code>的类型来调用适当的方法，该方法需要在接受者所属的类中搜寻其<code>方法列表</code>（list of methods），如果能找到与选择子名称相符的方法，就跳至其实现代码。如果找不到，就沿着继承体系继续向上查找，找到合适的方法再跳转。如果最终还是找不到，那就执行<code>消息转发</code>（message forwarding）</p>
<p>这么说来，想调用一个方法似乎需要很多步骤，但是，<code>objc_msgSend</code> 会将匹配结果缓存在<code>快速映射表</code>（fast map）里面，每个类都有这样一块缓存，如果稍后还向该类发送与选择子相同的消息，那么执行起来就很快了。</p>
<h3 id="9-2-其他消息传递"><a href="#9-2-其他消息传递" class="headerlink" title="9.2 其他消息传递"></a>9.2 其他消息传递</h3><h4 id="objc-msgSend-stret"><a href="#objc-msgSend-stret" class="headerlink" title="objc_msgSend_stret"></a>objc_msgSend_stret</h4><p>如果待发送的消息要返回结构体，可交由此函数处理。只有当 CPU 的寄存器能够容纳得下消息返回类型时，这个函数才能处理。如果返回的结构体太大了，就由另一个函数执行派发，会通过分配在栈上的某个变量来处理消息所返回的结构体。</p>
<h4 id="objc-msgSend-fpret"><a href="#objc-msgSend-fpret" class="headerlink" title="objc_msgSend_fpret"></a>objc_msgSend_fpret</h4><p>如果消息返回的是浮点数，那么可交由此函数处理。通常所用的 objc_msgSend 在这种情况下并不适合，这个函数是为了处理 x86 等架构 CPU 中某些奇怪状况。</p>
<h4 id="objc-msgSendSuper"><a href="#objc-msgSendSuper" class="headerlink" title="objc_msgSendSuper"></a>objc_msgSendSuper</h4><p>如果要给超类发消息，例如 <code>[super message:parameter]</code>，那么就交由此函数处理。也有另外两个与 <code>objc_msgSend_stret</code> 和 <code>objc_msgSend_fpret</code> 等效的函数，用于处理发给 super 的相应消息。</p>
<h3 id="9-3-尾调用优化"><a href="#9-3-尾调用优化" class="headerlink" title="9.3 尾调用优化"></a>9.3 尾调用优化</h3><p>每个类里都有一张表格，其中的指针都会指向这个函数，而选择子的名称则是查表时所用的 key，<code>objc_msgSend</code> 等函数的原理是，通过这张表格来寻找应该执行的方法。</p>
<p>原型的样子和 <code>objc_msgSend</code> 函数很像，这是利用<code>尾调用优化</code>（tail-call optimization）技术（函数最后一项操作是调用另外一个函数），编译器会生成跳转至另一个函数所需的指令码，而且不会向调用堆栈中推入新的<code>栈帧</code>（frame stack）。这项优化对 <code>objc_msgSend</code> 非常关键，如果不这么做的话，每次调用 Objective-C 方法之前，都需要为调用 <code>objc_msgSend</code> 函数准备栈帧。此外，若不优化，还会过早的发生<code>栈溢出</code>（stack overflow）现象。</p>
<h2 id="10-理解消息转发机制"><a href="#10-理解消息转发机制" class="headerlink" title="10. 理解消息转发机制"></a>10. 理解消息转发机制</h2><p>在编译期间向类发送了其无法解读的消息并不会报错，因为在运行期可以继续向类中添加方法。当对象接收到无法解读的消息后，就会启动<code>消息转发</code>（message forwarding）机制。</p>
<p>消息转发分为两大阶段：</p>
<h4 id="动态方法解析（dynamic-method-resolution）"><a href="#动态方法解析（dynamic-method-resolution）" class="headerlink" title="动态方法解析（dynamic method resolution）"></a>动态方法解析（dynamic method resolution）</h4><p>征询接收者，所属的类，看是否能动态添加方法，以处理当前这个<code>未知的选择子</code>（unknown selector）</p>
<h4 id="完整的消息转发机制（full-forwarding-mechanism）"><a href="#完整的消息转发机制（full-forwarding-mechanism）" class="headerlink" title="完整的消息转发机制（full forwarding mechanism）"></a>完整的消息转发机制（full forwarding mechanism）</h4><p>首先，接受者看看有没有其他对象能处理这条消息，如果有，运行时会把消息转给那个对象，消息转发过程结束，一切正常。若没有<code>备援的接收者</code>（replacement receiver）则启动完整的消息转发机制，运行时会把与消息有关的全部细节封装到 <code>NSInvocation</code> 对象中，再给接受者最后一次机会，令其设法解决当前还未处理的这条消息。</p>
<h3 id="10-1-动态方法解析"><a href="#10-1-动态方法解析" class="headerlink" title="10.1 动态方法解析"></a>10.1 动态方法解析</h3><p>对象在收到无法解读的消息后，首先将调用其所属类的下列类方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)selector</span><br></pre></td></tr></table></figure>
<p>如果尚未实现的方法是类方法，那么会调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)selector</span><br></pre></td></tr></table></figure>
<p>该方法的参数就是那个未知的选择子，其返回值为 BOOL 类型，表示这个类是否能新增一个实例方法用以处理此选择子。</p>
<p>使用这种方法的前提是：相关方法的实现代码已经写好，只等着运行时动态插在类里面就可以了。</p>
<p>举个例子，调用 Person 的 fly 方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">    </span><br><span class="line">SEL sel = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"fly"</span>);</span><br><span class="line">[p performSelector:sel];</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selString isEqualToString:<span class="string">@"fly"</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)fly, <span class="string">"v@:"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> fly(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"抱歉，人是不能飞的"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="10-2-备援的接收者"><a href="#10-2-备援的接收者" class="headerlink" title="10.2 备援的接收者"></a>10.2 备援的接收者</h3><p>如果上一步没有找到自定义的方法实现，这一步中，运行时系统会问它，能不能把这条消息转给其他接收者来处理</p>
<p>在上例中，如果 <code>resolveInstanceMethod:</code> 没有方法实现，则通过 <code>forwardingTargetForSelector:</code> 方法指定其他类来实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Bird.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Bird *bird;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (Bird *)bird</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_bird) &#123;</span><br><span class="line">        _bird = [[Bird alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _bird;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *selString = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="keyword">if</span> ([selString isEqualToString:<span class="string">@"fly"</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.bird;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>不用在 Bird.h 中暴露方法名，在 Bird.m 中实现即可</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Bird.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Bird</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fly</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我能飞"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="10-3-完整的消息转发"><a href="#10-3-完整的消息转发" class="headerlink" title="10.3 完整的消息转发"></a>10.3 完整的消息转发</h3><p>如果转发算法已经来到这一步的话，则启用完整的消息转发机制。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Bird.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Bird *bird;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (Bird *)bird</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_bird) &#123;</span><br><span class="line">        _bird = [[Bird alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _bird;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([Bird instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">            signature = [Bird instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([Bird instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.bird];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>接收者在每一步均有机会处理消息，步骤越往后，处理消息的代价就越大，最好能在第一步就处理完，这样的话，运行时就可以将此方法缓存取来了。若想在第三步里把消息转给备援的接收者，那还不如把转发操作提前到第二步。因为第三步只是修改了调用目标，这项改动放在第二步执行会更为简单，不然的话，还得创建并处理完整的 <code>NSInvocation</code></p>
<p><img src="/img/img026.jpg" alt="image026"></p>
<h2 id="11-自定义初始化方法"><a href="#11-自定义初始化方法" class="headerlink" title="11. 自定义初始化方法"></a>11. 自定义初始化方法</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"我的名字为：%@"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> reason:<span class="string">@"Person 类必须使用 initWithName: 方法初始化"</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="12-实现-description-方法"><a href="#12-实现-description-方法" class="headerlink" title="12. 实现 description 方法"></a>12. 实现 description 方法</h2><p>打印自定义的类结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person: 0x608000001530&gt;</span><br></pre></td></tr></table></figure>
<p>上面这种内容不太有用，所以我们应该在自己的类中覆写 description 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@ : %p&gt;, name = \"%@\" age = %lu"</span>, <span class="keyword">self</span>.class, <span class="keyword">self</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.age];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>创建并打印自定义类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">p.name = <span class="string">@"mayan"</span>;</span><br><span class="line">p.age = <span class="number">26</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, p);</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person : <span class="number">0x600000025560</span>&gt;, name = <span class="string">"mayan"</span> age = <span class="number">26</span></span><br></pre></td></tr></table></figure>
<p>以前还需要覆写 <code>debugDescription</code> 方法才能在断点时自定义打印，现在仅仅设置好 <code>description</code> 就可以了</p>
<h2 id="13-理解-NSCopying-协议"><a href="#13-理解-NSCopying-协议" class="headerlink" title="13. 理解 NSCopying 协议"></a>13. 理解 NSCopying 协议</h2><p>对象的拷贝通常使用 <code>copy</code> 方法完成，如果想令自己的类支持拷贝操作，那么就要实现 NSCopying 协议</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone;</span><br></pre></td></tr></table></figure>
<p>为何会出现 NSZone 呢？因为以前开发中，会据此把内存分为不同的<code>区</code>（zone），而对象会创建在某个区里面。现在不用了，每个程序只有一个<code>默认区</code>（default zone），所以实现这个方法，不必担心 zone 参数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> () &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="built_in">NSInteger</span>)age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _name = [name <span class="keyword">copy</span>];</span><br><span class="line">        _age  = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] initWithName:_name andAge:_age];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="14-协议、委托、分类"><a href="#14-协议、委托、分类" class="headerlink" title="14. 协议、委托、分类"></a>14. 协议、委托、分类</h2><p>Objective-C 语言有一项特性叫做<code>协议</code>（protocol），它与 Java 的<code>接口</code>（interface）类似。定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其<code>委托对象</code>（delegate），而这另一个对象则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。</p>
<p>此模式可将数据和业务逻辑解耦，比方说，用户界面里有个显示数据所用的视图，那么，此视图只应包含显示数据所需的逻辑代码，而不应决定要显示何种数据以及数据之间如何交互问题。视图对象的属性中，可以包含负责数据与事件处理的对象。这两种对象分别称为<code>数据源</code>（data source）与<code>委托</code>（delegate）</p>
<p>利用<code>分类</code>（Category）机制，我们无须继承子类即可直接为当前类添加方法，而在其他语言中，需通过继承子类来实现。由于 Objective-C 运行时是高度动态的，所以才能支持这一特性。</p>
<h2 id="15-以自动释放池块降低内存峰值"><a href="#15-以自动释放池块降低内存峰值" class="headerlink" title="15. 以自动释放池块降低内存峰值"></a>15. 以自动释放池块降低内存峰值</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> doSomethingWithInt:i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示代码，如果 <code>doSomethingWithInt:</code> 方法要创建临时对象，那么这些对象很可能放在自动释放池里，比方说，它们可能是一些临时字符串。但是，即使这些对象在调用完方法之后就不再使用，但是它们依然处于存活状态。这样一来，在执行 for 循环时，应用程序所占内存量就会持续上涨，等所有临时对象都释放之后，内存用量又突然下降。</p>
<p>如果把循环内的代码包裹在自动释放池块中，那么在循环中自动释放的对象就会放在这个池，而不是线程的主池里面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> doSomethingWithInt:i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，应用程序在执行循环时的内存峰值就会降低，但是是否应该用池来优化效率，完全取决于具体的应用程序。首先得监控内存用量，判断其中有没有需要解决的问题，别着急优化。尽管自动释放池块的开销不大，但是毕竟还是有的，所以尽量不要建立额外的自动释放池。</p>
<h2 id="16-理解-block"><a href="#16-理解-block" class="headerlink" title="16. 理解 block"></a>16. 理解 block</h2><p>当前多线程编程的核心就是<code>块</code>（block）和<code>大中枢派发</code>（Grand Central Dispatch，GCD），block 是一种在 C、C++、OC 中使用的<code>词法闭包</code>（lexical closure）</p>
<p><img src="/img/img027.png" alt="image027"></p>
<ul>
<li>在存放 block 对象的内存区域中，首个变量是 isa，指向 Class 对象的指针；</li>
<li>最重要的就是 invoke 变量，这是个函数指针，指向 block 的实现代码；</li>
<li>descriptor 变量是指向结构体的指针，其中声明了 block 对象的总体大小，还声明了 copy 和 dispose 这两个辅助函数所对应的函数指针，辅助函数在拷贝和丢弃 block 对象时运行，其中会执行一些操作，比如，前者要保留捕获的对象，后者将之释放；</li>
<li>block 还会把它所捕获的所有变量都拷贝一份，这些拷贝放在 descriptor 变量后面，捕获了多少个变量，就要占据多少内存空间。拷贝的并不是对象本身，而是指向这些对象的指针变量，原因是执行 block 时，要从内存中把这些捕获到的变量读出来。</li>
</ul>
<h2 id="17-多用派发队列，少用同步锁"><a href="#17-多用派发队列，少用同步锁" class="headerlink" title="17. 多用派发队列，少用同步锁"></a>17. 多用派发队列，少用同步锁</h2><p>防止多线程因为执行同一份代码而出问题，通常使用锁来实现某种同步机制。</p>
<h3 id="17-1-普通锁"><a href="#17-1-普通锁" class="headerlink" title="17.1 普通锁"></a>17.1 普通锁</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法的缺点是，滥用同步锁会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行，如果在 self 对象上频繁加锁，那么程序可能要等另一段与此无关的代码执行完毕，才能继续执行当前代码。</p>
<p>另一个办法是直接使用 NSLock 对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line"></span><br><span class="line">[_lock lock];</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">[_lock unlock];</span><br></pre></td></tr></table></figure>
<p>也可以使用 NSRecursiveLock 这种<code>递归锁</code>（recursive lock），线程能够多次持有该锁，而不会出现死锁（deadlock）现象。</p>
<p>这两种方法都很好，但是也有其缺陷，比如在极端情况下，同步块会导致死锁，另外其效率也不高，而如果直接使用锁对象的话，一旦遇到死锁，就会非常麻烦。</p>
<h3 id="17-2-GCD-相关锁"><a href="#17-2-GCD-相关锁" class="headerlink" title="17.2 GCD 相关锁"></a>17.2 GCD 相关锁</h3><p>有种简单高效的方法可以代替同步块或锁对象，那就是使用<code>串行同步队列</code>（serial synchronization queue），将读取操作、写入操作都安排在同一个队列里，即可保证数据同步</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_queue = dispatch_queue_create(<span class="string">"syncQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *localName;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^&#123;</span><br><span class="line">        localName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> localName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个更优的方法是，使用栅栏块来实现属性的设置方法，对属性的读取操作可以并发执行，但是写入操作却必须单独执行了。测试一下性能，发现这种做法比使用串行队列要快。</p>
<p><img src="/img/img028.png" alt="image028"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *localName;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^&#123;</span><br><span class="line">        localName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> localName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async(_queue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="18-多用-GCD，少用-performSelector-方法"><a href="#18-多用-GCD，少用-performSelector-方法" class="headerlink" title="18. 多用 GCD，少用 performSelector 方法"></a>18. 多用 GCD，少用 performSelector 方法</h2><p>performSelector 编程方式极为灵活，经常可以简化复杂的代码，但是如果在 ARC 下编译代码，那么编译器会发出内存泄漏的警告。原因在于，编译器并不知道将要调用的方法名和选择子，所以没有办法运用 ARC  的内存管理规则来判定返回值是不是应该释放，所以 ARC 比较谨慎，就是不添加释放操作，然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</p>
<p>替代方案就是使用 block，而且 performSelector 系列方法所提供的线程功能，都可以通过在大中枢派发机制中使用 block 来实现，延后执行可以用 dispatch_after，多线程可以使用 dispatch_sync 和 dispatch_async</p>
<h2 id="19-GCD-和-NSOperationQueue-使用时机"><a href="#19-GCD-和-NSOperationQueue-使用时机" class="headerlink" title="19. GCD 和 NSOperationQueue 使用时机"></a>19. GCD 和 NSOperationQueue 使用时机</h2><p>GCD 并不总是最佳方案，有的时候采用对象所带来的开销微乎其微，使用完整对象所带来的好处反而大大超过其缺点。</p>
<h4 id="取消某个操作"><a href="#取消某个操作" class="headerlink" title="取消某个操作"></a>取消某个操作</h4><p>如果使用 NSOperationQueue 取消操作是很容易的。运行任务前，可以在 NSOperation 对象上调用 cancel 方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。如果是使用 GCD 队列，那就无法取消了。</p>
<h4 id="指定操作间的依赖关系"><a href="#指定操作间的依赖关系" class="headerlink" title="指定操作间的依赖关系"></a>指定操作间的依赖关系</h4><p>一个操作可以依赖其他多个操作，开发者能够指定操作之间的依赖体系，使特定的操作必须在另外一个操作顺利执行完毕后方可执行。</p>
<h4 id="通过键值观察机制监控-NSOperation-对象的属性"><a href="#通过键值观察机制监控-NSOperation-对象的属性" class="headerlink" title="通过键值观察机制监控 NSOperation 对象的属性"></a>通过键值观察机制监控 NSOperation 对象的属性</h4><p>NSOperation 对象有许多属性都适合通过 KVO 来监听，比如可以通过 isCancelled 属性来判断任务是否已经取消，又比如可以通过 isFinished 属性来判断任务是否已经完成。</p>
<h4 id="指定操作的优先级"><a href="#指定操作的优先级" class="headerlink" title="指定操作的优先级"></a>指定操作的优先级</h4><p>GCD 的队列确实有优先级，不过那是针对整个队列来说的，而不是针对每个块来说的。因此，在优先级这一点上，NSOperationQueue 所提供的功能要比 GCD 更为便利</p>
<h2 id="20-不要使用-dispatch-get-current-queue"><a href="#20-不要使用-dispatch-get-current-queue" class="headerlink" title="20. 不要使用 dispatch_get_current_queue"></a>20. 不要使用 dispatch_get_current_queue</h2><p>使用 GCD 时，经常需要判断当前代码正在哪个队列上执行，我们会想到下面这个函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_current_queue();</span><br></pre></td></tr></table></figure>
<p>然而这个方法从 iOS 6.0 就已经弃用了，因为用它检测当前队列是不是某个特定的队列，以此来避免执行同步派发时，可能遭遇死锁问题。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *name;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^&#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法的问题在于，get 方法可能会死锁，假如调用 get 方法的队列恰好是 _queue，那么 dispatch_sync 就一直不会返回，直到 block 执行完毕为止。可是，应该执行 block 的那个目标队列确是当前队列，而当前队列的 dispatch_sync 又一直堵塞着，它在等待目标队列把这个 block 执行完，这样一来，block 就永远没有机会执行了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueA = dispatch_queue_create(<span class="string">"queueA"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueB = dispatch_queue_create(<span class="string">"queueB"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_sync</span>(queueA, ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queueB, ^&#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queueA, ^&#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面这段代码执行到最内层的派发操作时，总会死锁。因为此操作是针对 queueA 队列的，所以必须等最外层的 dispatch_sync 执行完毕才行，而最外层的 dispatch_sync 要等最内层的 dispatch_sync 执行完，于是就死锁了。将上面方法进行修改：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueA = dispatch_queue_create(<span class="string">"queueA"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueB = dispatch_queue_create(<span class="string">"queueB"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_sync</span>(queueA, ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queueB, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (dispatch_get_current_queue() == queueA) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">dispatch_sync</span>(queueA, ^&#123;</span><br><span class="line">               <span class="comment">// do something</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然而这样做依然死锁，因为 dispatch_get_current_queue 返回的是当前队列，也就是 queueB，这样针对 queueA 的同步派发操作依然会执行，于是还是死锁了。</p>
<p>要解决这个问题，最好的办法就是利用 <code>dispatch_queue_set_specific</code> 和 <code>dispatch_get_specific</code> 给 queue 关联一个 context data，后面再利用这个标识获取到 context data，如果可以获取到说明当前上下文是在自己创建的 queue 中，如果不能获取到则表示当前是在其他队列上。XMPP 中有比较多的使用案例。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueA = dispatch_queue_create(<span class="string">"queueA"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueB = dispatch_queue_create(<span class="string">"queueB"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *queueSpecificKey = <span class="string">@"queueSpecificKey"</span>;</span><br><span class="line">dispatch_queue_set_specific(queueA, queueSpecificKey, &amp;queueSpecificKey, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queueA, ^&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (dispatch_get_specific(queueSpecificKey)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"queueA - 当前为 queueA 队列"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"queueA - 当前为其他队列"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queueB, ^&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (dispatch_get_specific(queueSpecificKey)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"queueB - 当前为 queueA 队列"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"queueB - 当前为其他队列"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="21-Foundation-和-CoreFoundation-无缝桥接"><a href="#21-Foundation-和-CoreFoundation-无缝桥接" class="headerlink" title="21. Foundation 和 CoreFoundation 无缝桥接"></a>21. Foundation 和 CoreFoundation 无缝桥接</h2><h3 id="21-1-三种桥式转换"><a href="#21-1-三种桥式转换" class="headerlink" title="21.1 三种桥式转换"></a>21.1 三种桥式转换</h3><h4 id="bridge"><a href="#bridge" class="headerlink" title="__bridge"></a>__bridge</h4><p>ARC 仍然具备这个 Objective-C 对象的所有权</p>
<h4 id="bridge-retained"><a href="#bridge-retained" class="headerlink" title="__bridge_retained"></a>__bridge_retained</h4><p>与 __bridge 相反，意味着 ARC 将交出对象的所有权，用完需要 CFRelease 手动释放内存</p>
<h4 id="bridge-transfer"><a href="#bridge-transfer" class="headerlink" title="__bridge_transfer"></a>__bridge_transfer</h4><p>CoreFoundation 反向转换成 Foundation 类，令 ARC 获得对象所有权</p>
<h3 id="21-2-分析-CFMutableDictionary"><a href="#21-2-分析-CFMutableDictionary" class="headerlink" title="21.2 分析 CFMutableDictionary"></a>21.2 分析 CFMutableDictionary</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableDictionaryRef</span> dic =</span><br><span class="line">        <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(),</span><br><span class="line">                                  <span class="number">0</span>,</span><br><span class="line">                                  &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">                                  &amp;kCFTypeDictionaryValueCallBacks);</span><br></pre></td></tr></table></figure>
<p>首个参数表示将要使用的<code>内存分配器</code>（allocator）,CoreFoundation 对象里的数据结构需要占用内存，而分配器负责分配及回收这些内存。通常传入 NULL，表示采用默认的分配器。</p>
<p>第二个参数定义了字典的初始大小。并不会限制字典的最大容量，只是向分配器提示了一开始应该分配多少内存。假如要创建的字典含有 10 个对象，那就向该参数传入 10</p>
<p>最后两个参数值定义了许多回调函数，用于指示字典中的 key 和 value 在遇到各种事件时应该执行何种操作，点击进入这两个参数头文件可以看到其结构体如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span> version;</span><br><span class="line">    <span class="built_in">CFDictionaryRetainCallBack</span> <span class="keyword">retain</span>;</span><br><span class="line">    <span class="built_in">CFDictionaryReleaseCallBack</span> release;</span><br><span class="line">    <span class="built_in">CFDictionaryCopyDescriptionCallBack</span>	copyDescription;</span><br><span class="line">    <span class="built_in">CFDictionaryEqualCallBack</span>	equal;</span><br><span class="line">    <span class="built_in">CFDictionaryHashCallBack</span> hash;</span><br><span class="line">&#125; <span class="built_in">CFDictionaryKeyCallBacks</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span> version;</span><br><span class="line">    <span class="built_in">CFDictionaryRetainCallBack</span> <span class="keyword">retain</span>;</span><br><span class="line">    <span class="built_in">CFDictionaryReleaseCallBack</span> release;</span><br><span class="line">    <span class="built_in">CFDictionaryCopyDescriptionCallBack</span>	copyDescription;</span><br><span class="line">    <span class="built_in">CFDictionaryEqualCallBack</span> equal;</span><br><span class="line">&#125; <span class="built_in">CFDictionaryValueCallBacks</span>;</span><br></pre></td></tr></table></figure>
<p>version 参数用于检测新版与旧版数据结构之间是否兼容，目前应设为 0。结构体中其他成员都是函数指针，它们定义了当各种事件发生时应该采用哪个函数来执行相关任务。比如字典中加入新的 key 和 value，那么就会调用第二个 retain 函数。</p>
<h2 id="22-构建缓存时选用-NSCache-而非-NSDictionary"><a href="#22-构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="22. 构建缓存时选用 NSCache 而非 NSDictionary"></a>22. 构建缓存时选用 NSCache 而非 NSDictionary</h2><p>NSCache 胜过 NSDictionary 之处在于：</p>
<ol>
<li>当系统资源将要耗尽时，它可以自动删减缓存，如果采用字典，需要自己实现在系统低内存时发送通知删除缓存；</li>
<li>NSCache 还会先行删减最久未使用的对象，如果使用  NSDictionary 自己实现，会十分复杂；</li>
<li>NSCache 并不会拷贝键，而是会保留它，用 NSDictionary 实现的话需要相当复杂的代码。NSCache 对象不拷贝键的原因是：键是由不支持拷贝的对象来充当的；</li>
<li>NSCache 是线程安全的，而 NSDictionary 不具备此优势。在开发者不编写加锁代码的前提下，多个线程便可以同时访问 NSCache。</li>
</ol>
<p>下面这段代码演示了缓存的用法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _cache = [<span class="built_in">NSCache</span> new];</span><br><span class="line">        _cache.countLimit = <span class="number">100</span>;  <span class="comment">// Cache a maximum of 100 URLs</span></span><br><span class="line">        _cache.totalCostLimit = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadDataForURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *cacheData = [_cache objectForKey:url];</span><br><span class="line">    <span class="keyword">if</span> (cacheData) &#123;</span><br><span class="line">        <span class="comment">// get data</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MYNetworkFetcher *fetcher = [[MYNetworkFetcher alloc] initWithURL:url];</span><br><span class="line">        [fetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data) &#123;</span><br><span class="line">            [_cache setObject:data forKey:url cost:data.length];</span><br><span class="line">            <span class="comment">// get data</span></span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有个类叫做 NSPurgeableData，和 NSCache 搭配起来使用，效果更好，此类是 NSMutableData 的子类，而且实现了 NSDiscardableContent 协议。当系统资源紧张时，可以把保存 NSPurgeableData 对象的那块内存释放掉。NSDiscardableContent 协议里定义了名为 <code>isContentDiscarded</code> 的方法，可以用来查询相关内存是否已经释放。如果需要访问某个 NSPurgeableData 对象，可以调用其 <code>beginContentAccess</code> 方法，告诉它现在还不能丢弃自己所占据的内存。用完之后，调用 <code>endContentAccess</code> 方法，告诉它在必要时可以丢弃自己所占据的内存了。如果将 NSPurgeableData 对象加入 NSCache，那么当该对象为系统所丢弃时，也会自动从缓存中移除，通过 NSCache 的 <code>evictsObjectsWithDiscardedContent</code> 属性，可以开启或关闭此功能。修改代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _cache = [<span class="built_in">NSCache</span> new];</span><br><span class="line">        _cache.countLimit = <span class="number">100</span>;  <span class="comment">// Cache a maximum of 100 URLs</span></span><br><span class="line">        _cache.totalCostLimit = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadDataForURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="built_in">NSPurgeableData</span> *cacheData = [_cache objectForKey:url];</span><br><span class="line">    <span class="keyword">if</span> (cacheData) &#123;</span><br><span class="line">        [cacheData beginContentAccess];</span><br><span class="line">        <span class="comment">// get data</span></span><br><span class="line">        [cacheData endContentAccess];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MYNetworkFetcher *fetcher = [[MYNetworkFetcher alloc] initWithURL:url];</span><br><span class="line">        [fetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data) &#123;</span><br><span class="line">            <span class="built_in">NSPurgeableData</span> *purgeableData = [<span class="built_in">NSPurgeableData</span> dataWithData:data];</span><br><span class="line">            [_cache setObject:purgeableData forKey:url cost:purgeableData.length];</span><br><span class="line">            <span class="comment">// 创建好 NSPurgeableData 对象以后，其 purge 引用计数会多 1，所以无须再调用 beginContentAccess</span></span><br><span class="line">            <span class="comment">// 然而其后必须调用 endContentAccess，将多出来的这个 1 抵消掉</span></span><br><span class="line">            <span class="comment">// get data</span></span><br><span class="line">            [purgeableData endContentAccess];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>2017-05-05  一次阅读</p>
<p>去年阅读了一少半，然后因为项目耽搁了，而且笔记没有记得很清楚，所以这次又从头开始看。这本书还是很经典的，介绍了很多细节性的问题，理论性也很强，没有浪费这么长时间。</p>
<p>2018-01-24  二次阅读</p>
<p>很多概念性的东西时间长不看就容易遗忘，再次阅读并重新整理了理论知识，获益匪浅。有些知识并不是心里有大概的想法就算掌握，必须形成书面文字或者思路清晰的说出来才是真正的掌握。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/27/【读书笔记】《iOS 开发进阶（唐巧）》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mayan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mayan`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/27/【读书笔记】《iOS 开发进阶（唐巧）》/" itemprop="url">【读书笔记】《iOS 开发进阶（唐巧）》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-27T16:16:55+08:00">
                2017-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/27/【读书笔记】《iOS 开发进阶（唐巧）》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/27/【读书笔记】《iOS 开发进阶（唐巧）》/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者：唐巧</p>
<p>出版日期：2015-1-1</p>
<p>豆瓣地址：<a href="https://book.douban.com/subject/26287173/" target="_blank" rel="noopener">https://book.douban.com/subject/26287173/</a></p>
</blockquote>
<h2 id="一、CocoaPods-的安装和使用"><a href="#一、CocoaPods-的安装和使用" class="headerlink" title="一、CocoaPods 的安装和使用"></a>一、CocoaPods 的安装和使用</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>每种语言发展到一定阶段，都会出现相应的依赖管理工具，例如 Java 的 Maven、Node.js 的 npm 等。CocoaPods 是开发 iOS 应用程序的一个第三方库的依赖管理工具，起始于 2011 年 8 月，用 Ruby 写的。在没有使用 CocoaPods 以前，我们需要:</p>
<ol>
<li>把这些第三方开源库的源代码文件复制到项目中，或者设置成 git 的 <code>submodule</code>。</li>
<li>对于某些开源库，我还需要设置 -licucore 或者 -fno-objc-arc 等编译参数</li>
<li>管理这些依赖包的更新。</li>
</ol>
<p>这些体力活虽然简单，但毫无技术含量并且浪费时间。在使用 CocoaPods 之后，就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。</p>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>CocoaPods 的原理是将所有的依赖库都放到另一个名为 Pods 的项目中，然后让主项目依赖 Pods 项目。下面是一些技术细节：</p>
<ol>
<li>Pods 项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可</li>
<li>对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本每次项目编译时都会执行，将第三方库的各种资源文件复制到目标目录中</li>
<li>CocoaPods 通过一个名为 Pods.xcconfig 的文件在编译时设置所有的依赖和参数 </li>
</ol>
<h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h3><p>Mac 自带 ruby，如果 ruby 的开发工具包 gem 太老，首先升级 gem</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem update --system</span><br></pre></td></tr></table></figure>
<p>ruby 的软件源 rubygems.org 因为使用亚马逊的云服务，所以被墙了，需要更新一下 ruby 的源，下面代码将官方的 ruby 源替换成国内淘宝的源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/ </span><br><span class="line">$ gem sources -a https://ruby.taobao.org/</span><br></pre></td></tr></table></figure>
<p>验证 ruby 的源是否为淘宝镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure>
<p>使用 ruby 的 gem 命令即可下载安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br><span class="line">$ pod setup</span><br></pre></td></tr></table></figure>
<p>执行 pod setup 时，会输出 Setting up CocoaPods master repo 并等待好久，此时是 CocoaPods 将它的信息下载到 ~/.cocoapods 目录下。可以 cd 到那个目录，用 du -sh 来查看下载进度。</p>
<p>如果没有进度，那还需更换 ruby 镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --remove https://ruby.taobao.org/ </span><br><span class="line">$ gem sources -a https://gems.ruby-china.org/</span><br></pre></td></tr></table></figure>
<p>更换成功后再次下载安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br><span class="line">$ pod setup</span><br></pre></td></tr></table></figure>
<h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><p>在项目文件夹中创建名为 Podfile 的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch Podfile</span><br></pre></td></tr></table></figure>
<p>在文件中添加依赖库名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, ‘8.0’</span><br><span class="line"></span><br><span class="line">target ‘jiaheyingyuan’ do</span><br><span class="line">pod ‘AFNetworking’</span><br><span class="line">pod ‘SDWebImage’</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>如果不确定三方库版本，查找第三方库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod search AFNetworking</span><br></pre></td></tr></table></figure>
<p>然后在项目文件夹中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<ul>
<li>每次更改了 Podfile 文件，都需要重新执行一次 pod update 命令</li>
<li>执行 pod install 之后，会生成一个名为 Podfile.lock 的文件，不能把这个文件加入到 gitignore 中，因为 Podfile.lock 会锁定当前各依赖库的版本，之后执行 pod install 也不会更改版本，只有执行 pod update 才会改变 Podfile.lock。这样可以防止第三方库升级时造成大家各自的第三方库版本不一致。</li>
</ul>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><h4 id="为自己的项目创建-podspec-文件"><a href="#为自己的项目创建-podspec-文件" class="headerlink" title="为自己的项目创建 podspec 文件"></a>为自己的项目创建 podspec 文件</h4><p>参考以下两篇文章：</p>
<ul>
<li><a href="http://ishalou.com/blog/2012/10/16/how-to-create-a-cocoapods-spec-file/" target="_blank" rel="noopener">《如何编写一个 CocoaPods 的 spec 文件》</a></li>
<li><a href="http://studentdeng.github.io/blog/2013/09/13/cocoapods-tutorial/" target="_blank" rel="noopener">《Cocoapods 入门》</a></li>
</ul>
<h4 id="使用私有的-pods"><a href="#使用私有的-pods" class="headerlink" title="使用私有的 pods"></a>使用私有的 pods</h4><p>我们可以直接指定某一个依赖的 podspec，这样就可以使用企业内部的私有库。该方案有利于使企业内部的公共项目支持 CocoaPods，例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod &apos;MyCommon&apos;, :podspec =&gt; &apos;https://yuantiku.com/common/myCommon.podspec&apos;</span><br></pre></td></tr></table></figure>
<h4 id="不更新-podspec"><a href="#不更新-podspec" class="headerlink" title="不更新 podspec"></a>不更新 podspec</h4><p>在执行 pod install 和 pod update 时，默认先更新一次 podspec 索引，如下代码可以禁止其做索引更新操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pod install --no-repo-update</span><br><span class="line">$ pod update  --no-repo-update</span><br></pre></td></tr></table></figure>
<h4 id="生成第三方库的帮助文档"><a href="#生成第三方库的帮助文档" class="headerlink" title="生成第三方库的帮助文档"></a>生成第三方库的帮助文档</h4><p>如果你想让 CocoaPods 帮你生产第三方库的帮助文档，并集成到 Xcode 中，那么用 brew 安装 appledoc 即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install appledoc</span><br></pre></td></tr></table></figure>
<h2 id="二、网络封包分析工具-Charles"><a href="#二、网络封包分析工具-Charles" class="headerlink" title="二、网络封包分析工具 Charles"></a>二、网络封包分析工具 Charles</h2><p><img src="/img/img016.png" alt="image016"></p>
<h3 id="1-功能简介"><a href="#1-功能简介" class="headerlink" title="1. 功能简介"></a>1. 功能简介</h3><ul>
<li>支持 SSL 代理</li>
<li>支持流量控制，可以模拟慢速网络、等待时间较长的请求</li>
<li>支持 AJAX 调试，自动将 JSON 或 XML 数据格式化，方便查看</li>
<li>支持 AMF 调试，将 Flash Remoting 或 Flex Remoting 信息格式化，方便查看</li>
<li>支持重发网络请求，方便后端调试</li>
<li>支持修改网络请求参数</li>
<li>支持网络请求的截获和动态修改</li>
<li>检查 HTML、CSS、RSS 内容是否符合 W3C 标准（<a href="http://validator.w3.org）" target="_blank" rel="noopener">http://validator.w3.org）</a></li>
</ul>
<h3 id="2-安装和使用"><a href="#2-安装和使用" class="headerlink" title="2. 安装和使用"></a>2. 安装和使用</h3><h4 id="安装-Charles"><a href="#安装-Charles" class="headerlink" title="安装 Charles"></a>安装 Charles</h4><p>在 Charles 官方网站（<a href="https://www.charlesproxy.com）下载安装。" target="_blank" rel="noopener">https://www.charlesproxy.com）下载安装。</a></p>
<h4 id="安装-SSL-证书"><a href="#安装-SSL-证书" class="headerlink" title="安装 SSL 证书"></a>安装 SSL 证书</h4><p>如果需要截取分析 SSL 协议相关内容，那么需要安装 Charles 的 CA 证书（<a href="http://www.charlesproxy.com/ssl.zip）。解压后双击" target="_blank" rel="noopener">http://www.charlesproxy.com/ssl.zip）。解压后双击</a> .crt 文件，在钥匙串 -&gt; 系统 -&gt; 证书中可查看</p>
<h4 id="截取-Mac-上的网络封包"><a href="#截取-Mac-上的网络封包" class="headerlink" title="截取 Mac 上的网络封包"></a>截取 Mac 上的网络封包</h4><p>Charles 是通过将自己设置成代理服务器来完成封包截取的，将 Charles 设置成系统代理，菜单中 Proxy -&gt; Mac OS X Proxy 将 Charles 设置成系统代理。之后浏览网页就可以看到网络请求出现在 Charles 界面中。</p>
<h4 id="过滤网络请求"><a href="#过滤网络请求" class="headerlink" title="过滤网络请求"></a>过滤网络请求</h4><ul>
<li><p>在主界面的中部的 Filter 栏中填入需要过滤出来的关键字，比如 baidu。这种方法是临时性的封包过滤。</p>
</li>
<li><p>Proxy -&gt; Recording Settings -&gt; Include，选择添加一个项目，然后填入需要监控的协议、主机地址、端口号。这种方法是经常性的封包过滤。</p>
</li>
</ul>
<h4 id="截取-iPhone-上的网络封包"><a href="#截取-iPhone-上的网络封包" class="headerlink" title="截取 iPhone 上的网络封包"></a>截取 iPhone 上的网络封包</h4><p>Proxy -&gt; Proxy Settings 填入代理端口 8888，并勾选 Enable transparent HTTP proxying 然后在手机端设置代理即可</p>
<h4 id="模拟慢速网络"><a href="#模拟慢速网络" class="headerlink" title="模拟慢速网络"></a>模拟慢速网络</h4><p>Proxy -&gt; Throttle Setting 勾选 Enable Throttling 并且可以设置 Throttle Preset 的类型。如果只想模拟指定网站的慢速网络，可以勾选 Only for selected hosts 然后在对话框的下半部分设置中增加指定的 Hosts 项即可。</p>
<h4 id="截取-SSL-信息"><a href="#截取-SSL-信息" class="headerlink" title="截取 SSL 信息"></a>截取 SSL 信息</h4><p>在该请求上单机右键，选择 SSL Proxying 然后对于该 Host 的所有 SSL 请求都可以被截取到了</p>
<h4 id="修改网络请求内容"><a href="#修改网络请求内容" class="headerlink" title="修改网络请求内容"></a>修改网络请求内容</h4><p>调试接口时，我们需要反复尝试不同参数的网络请求，在网络请求上点击右键，选择 Edit 即可创建一个可编辑的网络请求，可修改 URL 地址、端口、参数等，修改完成后单击 Execute 即可发送</p>
<h4 id="修改服务器返回内容"><a href="#修改服务器返回内容" class="headerlink" title="修改服务器返回内容"></a>修改服务器返回内容</h4><p>Charles 提供了 Map、Rewrite、Breakpoints 功能，都可以达到修改服务器返回内容的目的。</p>
<ul>
<li>Map 适合长期将某一些请求重定向到另一个网络地址或本地文件</li>
<li>Rewrite 适合对网络请求进行一些正则替换</li>
<li>Breakpoints 适合做一些临时性的修改</li>
</ul>
<h4 id="Map-功能"><a href="#Map-功能" class="headerlink" title="Map 功能"></a>Map 功能</h4><p>Map 功能分为两种，进入方式 Tools -&gt; Map Remote 或 Map Local </p>
<ul>
<li>Map Remote：将指定的网络请求重定向到另一个网址</li>
<li>Map Local：将指定的网络请求重定向到本地文件</li>
</ul>
<p>对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。举例：Map From 测试服务器的请求重定向到 Map To 线上服务器。</p>
<p>对于 Map Local 功能，我们需要填写重定向的源地址和本地的目标文件。对于一些复杂的网络请求结果，我们可以先使用右键单击 Save Response 功能，将请求结果保存到本地，然后稍加修改，使其成为我们的目标映射文件。</p>
<h4 id="Rewrite-功能"><a href="#Rewrite-功能" class="headerlink" title="Rewrite 功能"></a>Rewrite 功能</h4><p>Rewrite 功能适合对某一类网络请求进行一些替换，以达到修改结果的目的。例如，一个 API 请求时获得用户昵称，将 Rewrite Rule 界面的 Match 的 value 设置之前的昵称，Replace 的 value 设置将要修改的昵称</p>
<h4 id="Breakpoints-功能"><a href="#Breakpoints-功能" class="headerlink" title="Breakpoints 功能"></a>Breakpoints 功能</h4><p>Rewrite 功能适合做批量和长期的替换，临时性的修改最好使用 Breakpoints 功能。Breakpoints 功能类似 Xcode 中设置的断点，当网络请求发生时，Charles 会截取该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。修改完成后单击 Execute 即可让网络请求继续进行。需要注意的是，使用 Breakpoints 功能将网络请求截取并修改的过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。</p>
<h2 id="三、其他一些实用的工具"><a href="#三、其他一些实用的工具" class="headerlink" title="三、其他一些实用的工具"></a>三、其他一些实用的工具</h2><h3 id="1-界面调试工具-Reveal"><a href="#1-界面调试工具-Reveal" class="headerlink" title="1. 界面调试工具 Reveal"></a>1. 界面调试工具 Reveal</h3><p><a href="http://revealapp.com" target="_blank" rel="noopener">Reveal</a> 可以在 iOS 开发时动态的查看和修改应用程序的界面。iOS 逆向工程中使用强大，可以分析他人的 APP，缺点是真特么贵。</p>
<p><img src="/img/img017.png" alt="image017"></p>
<h3 id="2-移动统计工具-Flurry"><a href="#2-移动统计工具-Flurry" class="headerlink" title="2. 移动统计工具 Flurry"></a>2. 移动统计工具 Flurry</h3><p><a href="http://www.flurry.com" target="_blank" rel="noopener">Flurry</a> 是一家专门为移动应用提供数据统计和分析的公司，使用 Flurry 服务的公司包括 eBay、Yahoo、Skype 等超过 11 万家公司。Flurry 优点：保持独立和专注，数据安全性更高。友盟已经被阿里收购，当用户的应用涉及的业务和阿里有类似或重合的时候，该统计数据有潜在的安全性问题</p>
<h3 id="3-崩溃日志记录工具-Crashlytics"><a href="#3-崩溃日志记录工具-Crashlytics" class="headerlink" title="3. 崩溃日志记录工具 Crashlytics"></a>3. 崩溃日志记录工具 Crashlytics</h3><p><a href="http://try.crashlytics.com" target="_blank" rel="noopener">Crashlytics</a> 是专门为移动应用开发者提供的保存和分析应用崩溃信息的专业工具。</p>
<h3 id="4-App-Store-统计工具-App-Annie"><a href="#4-App-Store-统计工具-App-Annie" class="headerlink" title="4. App Store 统计工具 App Annie"></a>4. App Store 统计工具 App Annie</h3><p><a href="http://www.appannie.com" target="_blank" rel="noopener">App Annie</a> 是一个 App Store 数据的统计分析工具。该工具可以统计 App 在 App Store 的下载量、排名变化、销售收入情况、用户评价等信息。</p>
<p>苹果官方的 iTunes Connect 提供的销售数据统计功能比较差，例如只能保存最近30天的详细销售数据、界面丑陋、无法查看应用的排名历史变化情况等</p>
<h3 id="5-Xcode-插件"><a href="#5-Xcode-插件" class="headerlink" title="5. Xcode 插件"></a>5. Xcode 插件</h3><ul>
<li>Alcatraz：管理 Xcode 插件、模板和颜色配置</li>
<li>KSImageNamed：自动弹出图片预览</li>
<li>BBUDebuggerTuckAway：智能弹出隐藏调试窗口</li>
<li>SCXcodeSwitchExpander：迅速地在 switch 语句中填充枚举类型的每种可能的取值</li>
<li>VVDocumenter：自动生成代码注释</li>
<li>ClangFormat：自动调整代码风格</li>
<li>ColorSense：编写 UIColor 时，实时预览相应的颜色</li>
</ul>
<h3 id="6-Dash"><a href="#6-Dash" class="headerlink" title="6. Dash"></a>6. Dash</h3><p>Dash 是一款 API 文档查询及代码片段管理工具，超级好用</p>
<h3 id="7-Appledoc"><a href="#7-Appledoc" class="headerlink" title="7. Appledoc"></a>7. Appledoc</h3><p>Appledoc 是一个从源代码中抽取文档的工具</p>
<h2 id="四、理解内存管理"><a href="#四、理解内存管理" class="headerlink" title="四、理解内存管理"></a>四、理解内存管理</h2><h3 id="1-什么是引用计数？"><a href="#1-什么是引用计数？" class="headerlink" title="1. 什么是引用计数？"></a>1. 什么是引用计数？</h3><p>引用计数可以有效地管理对象的生命周期。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象时，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。</p>
<h3 id="2-我们为什么需要引用计数"><a href="#2-我们为什么需要引用计数" class="headerlink" title="2. 我们为什么需要引用计数"></a>2. 我们为什么需要引用计数</h3><p>假如对象 A 将其中的对象 M 作为参数传递给对象 B，没有引用计数的情况下，内存管理原则是“谁申请谁释放”。那么要在 B 不再需要 M 的时候，A 将 M 销毁。但 B 可能只是临时用一下 M，也可能觉得 M 很重要，将它设置成自己的一个成员变量。这种情况下，什么时候销毁 M 就成了一个难题。</p>
<p>有一个暴力的做法，就是 A 调用完 B 之后，马上就销毁参数 M，然后 B 将参数另外复制一份 M2，自己管理 M2 的生命期。这种做法有一个很大的问题，就是它带来了更多的内存申请、复制、释放的工作，实在太影响性能。</p>
<p>还有另外一种做法，A 在构造完 M 之后，始终不销毁 M，由 B 来完成 M 的销毁工作。如果 B 需要长时间使用 M，就不销毁它，如果只是临时用一下，则可以用完马上销毁。这样好像很好的解决了对象复制的问题，但是它强烈依赖于 A、B 两个对象的配合。而且 M 申请在 A 中，释放在 B 中，使得它的内存管理代码分散在不同对象中，管理起来非常费劲。再复杂点，B 需要再向 C 传递 M，那么 M 在 C 中又不能让 C 管理，所以这种方式带来的复杂性更大。</p>
<p>所以引用计数很好的解决了这个问题，哪些对象需要长时间使用，就把它的引用计数加1，使用完了再把引用计数减1，对象的生命期管理可以完全交给引用计数了。</p>
<h3 id="3-不要向已经释放的对象发送消息"><a href="#3-不要向已经释放的对象发送消息" class="headerlink" title="3. 不要向已经释放的对象发送消息"></a>3. 不要向已经释放的对象发送消息</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [obj retainCount]);</span><br><span class="line">[obj release];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [obj retainCount]);</span><br></pre></td></tr></table></figure>
<p>输出结果可能是这样的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reference Count = <span class="number">1</span></span><br><span class="line">Reference Count = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>最后一次输出，引用计数为什么没有变成 0 呢？因为该对象的内存已经被回收，而我们向一个已经被回收的对象发了一个 retainCount 消息，所以它的输出结果应该是不确定的，如果该对象所占的内存被复用了，那么就有可能造成程序异常崩溃。</p>
<p>那为什么在这个对象被回收之后，这个不确定的值是 1 而不是 0 呢？因为当最后一次执行 release 时，系统知道马上就要回收内存了，就没有必要将 retainCount 减 1 了，因为不管减不减 1，该对象都肯定被回收，而对象被回收后，它所有的内存区域，包括 retainCount 值也变得没有意义。这样减少一次内存的操作，加速对象的回收。</p>
<h3 id="4-弱引用"><a href="#4-弱引用" class="headerlink" title="4. 弱引用"></a>4. 弱引用</h3><p>弱引用持有对象，但是不增加引用计数，这样就避免了循环引用的产生</p>
<h3 id="5-Core-Foundation-对象的内存管理"><a href="#5-Core-Foundation-对象的内存管理" class="headerlink" title="5. Core Foundation 对象的内存管理"></a>5. Core Foundation 对象的内存管理</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFStringRef</span> str = <span class="built_in">CFStringCreateWithCString</span>(kCFAllocatorDefault, <span class="string">"hello world"</span>, kCFStringEncodingUTF8);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">CFRetain</span>(str);  <span class="comment">// 引用计数 +1</span></span><br><span class="line"><span class="built_in">CFRelease</span>(str);  <span class="comment">// 引用计数 -1</span></span><br></pre></td></tr></table></figure>
<p>CFRetain 和 CFRelease 方法与 Objective-C 对象的 retain 和 release 方法等价。</p>
<p>将 Core Foundation 对象转换成一个 Objective-C 对象，引入了 bridge 相关关键字：</p>
<ul>
<li><code>__bridge</code>：只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法</li>
<li><code>__bridge_retained</code>：类型转换后，将相关对象的引用计数加 1，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法</li>
<li><code>__bridge_transfer</code>：类型转换后，将该对象的引用计数交给 ARC 管理，Core Foundation 对象在不用时，不再需要调用 CFRelease 方法</li>
</ul>
<h2 id="五、后台运行"><a href="#五、后台运行" class="headerlink" title="五、后台运行"></a>五、后台运行</h2><p>正常情况下，当应用按 Home 键退出后，应用仅有最多 5 秒时间做一些保存后请理资源的工作。但是应用可以调用后台方法，让应用最多有 10 分钟的时间在后台长久运行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UIBackgroundTaskIdentifier</span> backgroundUpdateTask;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> beingBackgroundUpdateTask];</span><br><span class="line">    <span class="comment">// 在这里加上你需要长久运行的代码</span></span><br><span class="line">    [<span class="keyword">self</span> endBackgroundUpdateTask];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)beingBackgroundUpdateTask &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">self</span>.backgroundUpdateTask = [[<span class="built_in">UIApplication</span> sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        [<span class="keyword">self</span> endBackgroundUpdateTask];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)endBackgroundUpdateTask &#123;</span><br><span class="line"> </span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] endBackgroundTask:<span class="keyword">self</span>.backgroundUpdateTask];</span><br><span class="line">    <span class="keyword">self</span>.backgroundUpdateTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、UIWindow-应用场景"><a href="#六、UIWindow-应用场景" class="headerlink" title="六、UIWindow 应用场景"></a>六、UIWindow 应用场景</h2><h3 id="1-WindowLevel"><a href="#1-WindowLevel" class="headerlink" title="1. WindowLevel"></a>1. WindowLevel</h3><p>UIWindow 有一个类型为 <code>UIWindowLevel</code> 的属性，该属性定义了 UIWindow 的层级，系统定义的一共有 3 种取值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIWindowLevelNormal</span>    = <span class="number">0</span> </span><br><span class="line"><span class="built_in">UIWindowLevelStatusBar</span> = <span class="number">1000</span></span><br><span class="line"><span class="built_in">UIWindowLevelAlert</span> 	   = <span class="number">2000</span></span><br></pre></td></tr></table></figure>
<p>默认程序的 UIWindow 的层级就是 UIWindowLevelNormal，当系统需要在其上面覆盖 UIAlertView 时，就会创建一个层级为 UIWindowLevelAlert 的 UIWindow。在实际应用中，WindowLevel 的取值并不限于这 3 个值。</p>
<h3 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h3><p>适合用 UIWindow 来实现的功能包括：手势解锁、启动页、通知提醒显示、弹框广告等。可以封装成一个单例，方便调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MYAlertWindow</span> : <span class="title">UIWindow</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)show;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MYAlertWindow.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MYAlertWindow</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> grayColor];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span>)];</span><br><span class="line">        label.center = <span class="keyword">self</span>.center;</span><br><span class="line">        label.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        label.text = <span class="string">@"警告"</span>;</span><br><span class="line">        label.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">        [<span class="keyword">self</span> addSubview:label];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UITapGestureRecognizer</span> *tap = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapClick)];</span><br><span class="line">        [<span class="keyword">self</span> addGestureRecognizer:tap];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tapClick &#123;</span><br><span class="line">    [<span class="keyword">self</span> resignKeyWindow];</span><br><span class="line">    <span class="keyword">self</span>.hidden = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)show &#123;</span><br><span class="line">    [<span class="keyword">self</span> makeKeyWindow];</span><br><span class="line">    <span class="keyword">self</span>.hidden = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>调用下列方法即可使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[MYAlertWindow sharedInstance] show];</span><br></pre></td></tr></table></figure>
<h2 id="七、动态下载系统提供的多种中文字体"><a href="#七、动态下载系统提供的多种中文字体" class="headerlink" title="七、动态下载系统提供的多种中文字体"></a>七、动态下载系统提供的多种中文字体</h2><p>字体文件通常比较大，10 ~ 20 MB 是常见的字体库的大小，如果只是很少量的字体需要设置，导入整个字体库是不划算的，并且中文字体通常都是有版权的，所以使用特殊中文字体库的 iOS 应用较少，通常只有阅读类的应用才会使用特殊中文字体库。从 iOS 6 开始，苹果支持动态下载中文字体到系统中，使用系统提供的中文字体，既可以避免版权问题，又可以减少应用体积。</p>
<p>首先需要使用 Mac 内自带的应用“字体册”（Font Book）来获得相应字体的 PostScript 名称。</p>
<p>假如我们现在要下载“娃娃体”，它的 PostScript 名称为“DFWaWaSC-W5”，首先判断该字体是否已经被下载下来</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isfontDownloaded:(<span class="built_in">NSString</span> *)fontName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIFont</span> *aFont = [<span class="built_in">UIFont</span> fontWithName:fontName size:<span class="number">12.0</span>];</span><br><span class="line">    <span class="keyword">if</span> (aFont &amp;&amp; ([aFont.fontName compare:fontName] == <span class="built_in">NSOrderedSame</span> || [aFont.familyName compare:fontName] == <span class="built_in">NSOrderedSame</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该字体没有下载过，我们需要准备下载字体 API 需要的一些参数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *attrs = [<span class="built_in">NSMutableDictionary</span> dictionaryWithObjectsAndKeys:fontName, kCTFontNameAttribute, <span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建一个字体描述对象</span></span><br><span class="line"><span class="built_in">CTFontDescriptorRef</span> desc = <span class="built_in">CTFontDescriptorCreateWithAttributes</span>((__bridge <span class="built_in">CFDictionaryRef</span>)attrs);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSMutableArray</span> *descs = [<span class="built_in">NSMutableArray</span> arrayWithObject:(__bridge <span class="keyword">id</span> _Nonnull)(desc)];</span><br><span class="line"><span class="built_in">CFRelease</span>(desc);</span><br></pre></td></tr></table></figure>
<p>准备好上面的 descs 变量后，就可以进行字体的下载了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">BOOL</span> errorDuringDownload = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">CTFontDescriptorMatchFontDescriptorsWithProgressHandler</span>((__bridge <span class="built_in">CFArrayRef</span>)descs, <span class="literal">NULL</span>, ^<span class="keyword">bool</span>(<span class="built_in">CTFontDescriptorMatchingState</span> state, <span class="built_in">CFDictionaryRef</span>  _Nonnull progressParameter) &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">double</span> progressValue = [[(__bridge <span class="built_in">NSDictionary</span> *)progressParameter objectForKey:(<span class="keyword">id</span>)kCTFontDescriptorMatchingPercentage] doubleValue];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (state == kCTFontDescriptorMatchingDidBegin) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"字体已经匹配"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == kCTFontDescriptorMatchingDidFinish) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!errorDuringDownload) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"字体 %@ 下载完成"</span>, fontName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == kCTFontDescriptorMatchingWillBeginDownloading) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"字体开始下载"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == kCTFontDescriptorMatchingDidFinishDownloading) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"字体下载完成"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == kCTFontDescriptorMatchingDownloading) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载进度 %.0f%%"</span>, progressValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == kCTFontDescriptorMatchingDidFailWithError) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error = [(__bridge <span class="built_in">NSDictionary</span> *)progressParameter objectForKey:(<span class="keyword">id</span>)kCTFontDescriptorMatchingError];</span><br><span class="line">        errorDuringDownload = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通常需要在下载完字体后开始使用字体，一般是将响应代码放到 kCTFontDescriptorMatchingDidFinish 条件中，用 GCD 修改 UI 或者发 Notification 来通知相应的 Controller。</p>
<h2 id="八、安全性问题"><a href="#八、安全性问题" class="headerlink" title="八、安全性问题"></a>八、安全性问题</h2><h3 id="密文传输密码"><a href="#密文传输密码" class="headerlink" title="密文传输密码"></a>密文传输密码</h3><p>事先生成一对用于加密的公私钥，客户端在登录时，使用公钥将用户的密码加密后，将密文传输到服务器。服务器使用私钥将密码解密，然后加盐（Salt：在密码学中，指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符）之后再多次求 MD5，之后再和服务器原来存储的用同样方法处理过的密码匹配，如果一致，则登录成功。这样，即使截获了加密后的密文，由于没有私钥，也无法还原出原始的密码。</p>
<h3 id="JSON-字段加密"><a href="#JSON-字段加密" class="headerlink" title="JSON 字段加密"></a>JSON 字段加密</h3><p>如果通讯协议被破解，黑客可以模拟客户端登录，进而伪造一些用户行为，可能对用户数据造成危害。我们可以选择类似 <a href="https://code.google.com/p/protobuf/protobuf" target="_blank" rel="noopener">Protobuf</a>（Google 提供的开源数据交换格式，其最大特点是基于二进制，比传统的 JSON 格式要小很多）之类的二进制通讯协议或者自己实现通讯协议，对于传输的内容进行一定程度的加密。</p>
<h3 id="程序文件加密"><a href="#程序文件加密" class="headerlink" title="程序文件加密"></a>程序文件加密</h3><p>很多应用的部分逻辑是用 Web 方式实现的，解压包内容可以看到 js 文件，这些文件都有完整清晰的注释，很容易知道其调用逻辑。通过将 js 源码进行混淆和加密，可以防止黑客轻易地阅读和篡改相关的逻辑，也可以防止 Web 端和 Native 端的通讯协议泄漏。</p>
<h3 id="本地数据加密"><a href="#本地数据加密" class="headerlink" title="本地数据加密"></a>本地数据加密</h3><p>比如一款游戏，打开本地文件，可以容易地看到各种属性变量的名称和参数，我们就可以简单修改，达到修改游戏参数的目的，淘宝上许多商家就是如此操作。对于本地的重要数据，我们应该加密存储或者将其保存到 keychain 中，以保证其不被篡改。 </p>
<h3 id="源代码安全"><a href="#源代码安全" class="headerlink" title="源代码安全"></a>源代码安全</h3><p>通过 <a href="https://www.hex-rays.com/products/ida/" target="_blank" rel="noopener">IDA</a> 这类工具进行反编译，可以反汇编到可以方便阅读的程度，更加方便地分析出应用的通讯协议和数据加密方式。对于这类工具，我们的应对措施就比较少了，除了用一些宏来简单混淆类名外，我们也可以将关键的逻辑用存 C 实现，例如微信的 iOS 端通讯底层，就是用 C 实现的。这样的方式除了能保证通讯协议安全外，还可以在 iOS 和 Android 使用同一套底层通讯代码，达到复用的目的。</p>
<h2 id="九、基于-CoreText-的排版引擎"><a href="#九、基于-CoreText-的排版引擎" class="headerlink" title="九、基于 CoreText 的排版引擎"></a>九、基于 CoreText 的排版引擎</h2><p>CoreText 是用于处理文字和字体的底层技术，它直接和 Core Graphics（又称为 Quartz）打交道。Quartz 是一个 2D 图形渲染引擎，能够处理 OSX 和 iOS 中的图形显示问题。使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片、链接的点击效果。CoreText 技术相对于 UIWebView 有内存占用少，可以后台渲染的优点，非常适合排版工作。</p>
<h3 id="1-CoreText-和-UIWebView-比较"><a href="#1-CoreText-和-UIWebView-比较" class="headerlink" title="1. CoreText 和 UIWebView 比较"></a>1. CoreText 和 UIWebView 比较</h3><p><img src="/img/img018.png" alt="image018"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>CoreText 占用的内存少，渲染速度更快；</li>
<li>CoreText 在渲染界面前就可以精确的获得显示内容的高度（只要有了 CTFrame 即可），而 UIWebView 只有渲染出内容后，才能获得内容的高度（而且还需要用 JavaScript 代码来获取）；</li>
<li>CoreText 的 CTFrame 可以在后台线程渲染，UIWebView 的内容只能在主线程渲染；</li>
<li>基于 CoreText 可以做更好的原生交互效果，而 UIWebView 的交互效果都是用 JavaScript 来实现的，在交互效果上会有一些卡顿情况存在。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>CoreText 渲染出来的内容不能像 UIWebView 那样方便的支持内容的复制；</li>
<li>基于 CoreText 来排版需要自己处理很多复杂的逻辑，例如需要自己处理图片和文字混排相关的逻辑，也需要自己实现链接点击操作的支持。</li>
</ul>
<h3 id="2-基于-CoreText-的排版引擎框架"><a href="#2-基于-CoreText-的排版引擎框架" class="headerlink" title="2. 基于 CoreText 的排版引擎框架"></a>2. 基于 CoreText 的排版引擎框架</h3><p>这部分没有细看，待总结，具体文章内容和示例点击<a href="https://github.com/mayan29/BlogCode/tree/master/【读书笔记】《iOS%20开发进阶（唐巧）》" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="十、开发技巧"><a href="#十、开发技巧" class="headerlink" title="十、开发技巧"></a>十、开发技巧</h2><h3 id="1-申请加急审核"><a href="#1-申请加急审核" class="headerlink" title="1. 申请加急审核"></a>1. 申请加急审核</h3><ol>
<li>访问 iTunes Connect 网站：<a href="https://itunesconnect.apple.com" target="_blank" rel="noopener">https://itunesconnect.apple.com</a> </li>
<li>单击网站底部的 Contact Us 按钮</li>
<li>在问题 1 中选择 App Review</li>
<li>在问题 2 中选择 Request Expedited Review</li>
<li>单击 Request an Expedited App Review 按钮即可填写加急审核的申请表。最好使用英文填写，最容易通过的理由是严重的崩溃 bug（在理由一栏选择 Critical Bug Fix），在原因处详细描述该 bug 的重现步骤，则很容易使申请通过。</li>
</ol>
<h3 id="2-如何将应用下架"><a href="#2-如何将应用下架" class="headerlink" title="2. 如何将应用下架"></a>2. 如何将应用下架</h3><p>最简单的办法是将应用的上架时间改成未来的一个时间，这样就会在数小时之内下架</p>
<h3 id="3-收起键盘的其他方式"><a href="#3-收起键盘的其他方式" class="headerlink" title="3. 收起键盘的其他方式"></a>3. 收起键盘的其他方式</h3><p>在 UIViewController 中收起键盘，除了调用相应控件的 <code>resignFirstResponder</code> 方法外，还有另外三种方法：</p>
<ol>
<li><p>重载 UIViewController 中的 <code>touchesBegin</code> 方法，然后在里面执行 <code>[self.view endEditing:YES];</code>，这样点击 UIViewController 任意地方，就可以收起键盘；</p>
</li>
<li><p>直接执行 <code>[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</code>，用于在获取当前 UIViewController 比较困难的时候使用；</p>
</li>
<li><p>直接执行 <code>[[UIApplication sharedApplication].keyWindow endEditing:YES];</code></p>
</li>
</ol>
<h3 id="4-NSJSONSerialization-比-NSKeyedArchiver-更好"><a href="#4-NSJSONSerialization-比-NSKeyedArchiver-更好" class="headerlink" title="4. NSJSONSerialization 比 NSKeyedArchiver 更好"></a>4. NSJSONSerialization 比 NSKeyedArchiver 更好</h3><p>在选择持久化方案时，系统提供的 NSJSONSerialization 比 NSKeyedArchiver 在效率和体积上都更优。经过测试，NSJSONSerialization 比 NSKeyedArchiver 快了 7 倍，而且序列化之后的体积是 NSKeyedArchiver 的一半。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSJSONSerialization 开始存储"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSMutableArray</span> *persons1 = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    [persons1 addObject:[<span class="built_in">NSJSONSerialization</span> dataWithJSONObject:dic options:<span class="number">0</span> error:<span class="literal">nil</span>]];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSJSONSerialization 结束存储"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSKeyedArchiver 开始存储"</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSMutableArray</span> *persons2 = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    [persons2 addObject:[<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:dic]];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSKeyedArchiver 结束存储"</span>);</span><br></pre></td></tr></table></figure>
<p>测试结果为：NSJSONSerialization 用了 0.426 秒，NSKeyedArchiver 用了 4.344 秒</p>
<h3 id="5-设置应用内的系统控件语言"><a href="#5-设置应用内的系统控件语言" class="headerlink" title="5. 设置应用内的系统控件语言"></a>5. 设置应用内的系统控件语言</h3><p>在 iOS 系统中，有时候会需要调用系统的一些 UI 控件，例如：</p>
<ul>
<li>在 UIWebView 中长按会弹出系统的上下文菜单；</li>
<li>在 UIImagePickerController 中会使用系统的照相机界面；</li>
<li>在编辑状态下的 UITableViewCell 处于待删除状态时，会有一个系统的删除按钮；</li>
</ul>
<p>以上 UI 控件中，显示的语言并不是和你当前手机的系统语言一致的，语言设置成中文，需要在 info.plist 文件中增加以下内容即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;CFBundleLocalizations&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">	&lt;string&gt;zh_CN&lt;/string&gt;</span><br><span class="line">	&lt;string&gt;en&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure>
<h3 id="6-用截屏功能来实现侧滑返回效果"><a href="#6-用截屏功能来实现侧滑返回效果" class="headerlink" title="6. 用截屏功能来实现侧滑返回效果"></a>6. 用截屏功能来实现侧滑返回效果</h3><p>iOS 7 以后的系统，可以通过系统提供的 API 来实现截屏功能</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)snapshotViewAfterScreenUpdates:(<span class="built_in">BOOL</span>)afterUpdates;</span><br></pre></td></tr></table></figure>
<p>早期的 QQ 在侧滑到一半的时候，整个当前界面被移动到了右半部分，同时在左半部分以半透明的方式露出了上一个界面。由于 ViewController 并不支持自己的 view 设置透明，所以需要我们自己实现。</p>
<p>为了使用截屏功能达到这种效果，我们在 NavigationController 进入到一个新的 ViewController 前，先进行截屏操作，保存当前的界面效果，然后将截到的当前界面作为参数，传递给目标 ViewController 当作背景。</p>
<p>这样，平时这个背景我们用内容遮挡住，当用户用手指向右滑动，我们将整个界面右移，露出这个背景，于是就会像看到了上一个 ViewController 一样。</p>
<h3 id="7-内存警告"><a href="#7-内存警告" class="headerlink" title="7. 内存警告"></a>7. 内存警告</h3><ol>
<li>CALayer 是一个 bitmap 图像的容器类，当 UIView 调用自身的 drawRect 时，CALayer 才会创建这个 bitmap 图像类。</li>
<li>CALayer 只占 48 Bytes，UIView 只占 96 Bytes，而一个 iPad 的全屏 UIView 的 bitmap 类会占到 12 MB 的大小！</li>
<li>当系统发出 MemoryWarning 时，系统会自动回收 bitmap 类，但是不回收 UIView 和 CALayer 类。这样既能回收大部分内存，又能在需要 bitmap 类时，通过调用 UIView 的 drawRect 方法重建。</li>
<li>当一段内存被分配时，它会被标记成 In use 以防止被重复使用，当内存被释放时，这段内存会被标记成 Not in use，这样在有新的内存申请时，这块内存就可能被分配给其他变量。</li>
<li>CALayer 包括的具体的 bitmap 内容的私有成员变量类型为 CABackingStore，当收到 MemoryWarning 时，CABackingStore 类型的内存区会被标记成可能再次被原变量使用。</li>
</ol>
<h3 id="8-Xcode-快捷键"><a href="#8-Xcode-快捷键" class="headerlink" title="8. Xcode 快捷键"></a>8. Xcode 快捷键</h3><h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>Cmd + Ctrl + Up</td>
<td>在 .h 和 .m 文件之间切换</td>
</tr>
<tr>
<td>Cmd + Ctrl + Left</td>
<td>到上 / 下一次编辑的位置</td>
</tr>
<tr>
<td>Cmd + Shift + F</td>
<td>在工程中查找</td>
</tr>
<tr>
<td>Cmd + .</td>
<td>结束本次调试</td>
</tr>
</tbody>
</table>
<h4 id="不太常用快捷键"><a href="#不太常用快捷键" class="headerlink" title="不太常用快捷键"></a>不太常用快捷键</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>Cmd + Shift + Y</td>
<td>切换控制台的显示或隐藏</td>
</tr>
<tr>
<td>Cmd + 0</td>
<td>隐藏左边的导航区</td>
</tr>
<tr>
<td>Cmd + Opt + 0</td>
<td>隐藏右边的工具区</td>
</tr>
<tr>
<td>Cmd + Shift + K</td>
<td>清空编译好的文件</td>
</tr>
</tbody>
</table>
<h3 id="9-为工程增加-Daily-Build"><a href="#9-为工程增加-Daily-Build" class="headerlink" title="9. 为工程增加 Daily Build"></a>9. 为工程增加 Daily Build</h3><p>我们可以用 bash 写一个 Daily Build 脚本，可以参考 @lexrus 的自动打包脚本 <a href="https://github.com/lexrus/ios-makefile" target="_blank" rel="noopener">ios-makefile</a></p>
<h2 id="十一、Objective-C-对象"><a href="#十一、Objective-C-对象" class="headerlink" title="十一、Objective-C 对象"></a>十一、Objective-C 对象</h2><h3 id="1-isa-指针"><a href="#1-isa-指针" class="headerlink" title="1. isa 指针"></a>1. isa 指针</h3><p>我们进入 <code>NSObject.h</code> 和 <code>objc.h</code> 可以看到，NSObject 就是一个包含 isa 指针的结构体：</p>
<p><img src="/img/img019.png" alt="image019"></p>
<p><img src="/img/img020.png" alt="image020"></p>
<p>按照面向对象语言的设计原则，所有事物都应该是对象，严格来说，Objective-C 并没有完全做到这一点，因为它有像 int、double 这样的简单变量类型，而类似 Ruby 一类语言，连 int 变量也是对象。</p>
<p>我们进入 <code>runtime.h</code> 中打开 Class 的定义头文件，可以看到，Class 也是一个包含 isa 指针的结构体</p>
<p><img src="/img/img021.png" alt="image021"></p>
<p>类也是一个对象，所以它也必须是另一个类的实例，这个类就是元类（metaclass），元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现。</p>
<p>元类也是一个对象，那么元类的 isa 指针又指向哪里呢？为了设计上的完整，所有元类 isa 指针都会指向一个根元类（root metaclass），根元类本身的 isa 指针指向自己，这样就形成了一个闭环。</p>
<h3 id="2-类的成员变量"><a href="#2-类的成员变量" class="headerlink" title="2. 类的成员变量"></a>2. 类的成员变量</h3><p>如果把类的实例看成一个 C 语言的结构体，上面说的 isa 指针就是这个结构体的第一个成员变量，而类的其他成员变量依次排列在结构体中。为了验证排列顺序，在 main.m 中运行如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _father;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Father</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Child</span> : <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Child</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    Child *child = [[Child alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 @autoreleasepool 处打断点，在 Console 中输入 <code>p *child</code> 则可以看到输出如下</p>
<p><img src="/img/img022.png" alt="image022"></p>
<p>因为对象在内存中排布可以看成一个结构体，结构体的大小并不能动态变化，所以无法在运行时动态地给对象添加成员变量。但是对象的方法定义都保存在类的可变区域中，通过修改方法列表的指针，就可以动态地为某一个类增加成员变量，这也是 Category 实现的原理，同时也说明了为什么 Category 只能为对象增加成员方法，却不能增加成员变量。</p>
<h3 id="3-动态创建类和对象"><a href="#3-动态创建类和对象" class="headerlink" title="3. 动态创建类和对象"></a>3. 动态创建类和对象</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为 MYView 的类，它是 UIView 的子类</span></span><br><span class="line">    Class newClass = objc_allocateClassPair([<span class="built_in">UIView</span> <span class="keyword">class</span>], <span class="string">"MYView"</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为该类增加一个名为 report 的方法</span></span><br><span class="line">    class_addMethod(newClass, <span class="built_in">NSSelectorFromString</span>(<span class="string">@"report"</span>), (IMP)ReportFunction, <span class="string">"v@:"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册该类</span></span><br><span class="line">    objc_registerClassPair(newClass);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个 MYView 类的实例</span></span><br><span class="line">    <span class="keyword">id</span> instanceOfNewClass = [[newClass alloc] init];</span><br><span class="line">    <span class="comment">// 调用 report 方法</span></span><br><span class="line">    [instanceOfNewClass performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"report"</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ReportFunction(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Class is %@, and super is %@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], [<span class="keyword">self</span> superclass]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class is MYView, and <span class="keyword">super</span> is <span class="built_in">UIView</span></span><br></pre></td></tr></table></figure>
<h3 id="4-动态方法替换"><a href="#4-动态方法替换" class="headerlink" title="4. 动态方法替换"></a>4. 动态方法替换</h3><p>4.1. <code>method_exchangeImplementations</code>，最常用的方法，当需要交换两个方法的实现时使用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method viewWillAppear = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewWillAppear:));</span><br><span class="line">Method bimViewWillAppear = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(bimViewWillAppear:));</span><br><span class="line">method_exchangeImplementations(viewWillAppear, bimViewWillAppear);</span><br></pre></td></tr></table></figure>
<p>4.2. <code>class_replaceMethod</code>，当被替换的方法有可能没有实现时使用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line">    </span><br><span class="line">    SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">    SEL swizzledSelector = <span class="keyword">@selector</span>(bimViewWillAppear:);</span><br><span class="line">    </span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)bimViewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了 bimViewWillAppear: 方法"</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> bimViewWillAppear:animated];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用了 bimViewWillAppear: 方法</span><br></pre></td></tr></table></figure>
<p>如果在该类中实现了 <code>viewWillAppear:</code> 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了 viewWillAppear: 方法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用了 viewWillAppear: 方法</span><br></pre></td></tr></table></figure>
<p>说明 <code>didAddMethod</code> 返回 NO，没有实现方法交换。</p>
<p>其实使用 <code>viewWillAppear:</code> 方法并没有展示出来该方法的作用。比较实用的地方用在：子类继承父类，在子类中没有父类方法的覆写，子类的扩展类中实现父类方法交换。</p>
<p>4.3. <code>method_setImplementation</code>，直接为一个方法设置其实现方式时使用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Method method1 = class_getInstanceMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(work));</span><br><span class="line">    Method method2 = class_getInstanceMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(study));</span><br><span class="line">    IMP imp2 = method_getImplementation(method2);</span><br><span class="line">    </span><br><span class="line">    method_setImplementation(method1, imp2);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> work];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)work &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"工作"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)study &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"学习"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学习</span><br></pre></td></tr></table></figure>
<p>其实 <code>method_exchangeImplementations</code> 方法就是调用了两次 <code>method_setImplementation</code></p>
<h2 id="十二、Tagged-Pointer-对象"><a href="#十二、Tagged-Pointer-对象" class="headerlink" title="十二、Tagged Pointer 对象"></a>十二、Tagged Pointer 对象</h2><p>iPhone 5s 配备了首个采用 64 位架构的 A7 双核处理器，同时提出了 Tagged Pointer 的概念。对于 64 位系统，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，3 倍的访问速度提升，100 倍的创建、销毁速度提升。</p>
<h3 id="1-原有系统的问题"><a href="#1-原有系统的问题" class="headerlink" title="1. 原有系统的问题"></a>1. 原有系统的问题</h3><p>举个例子：</p>
<ul>
<li>NSNumber 对象，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下占 8 个字节；</li>
<li>指针在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下占 8 个字节；</li>
</ul>
<p>所以如果没有 Tagged Pointer 对象，从 32 位机器迁移到 64 位机器中，虽然逻辑没有变化，但是对象所占用的内存会翻倍：</p>
<p><img src="/img/img023.jpg" alt="image023"></p>
<h3 id="2-Tagged-Pointer-介绍"><a href="#2-Tagged-Pointer-介绍" class="headerlink" title="2. Tagged Pointer 介绍"></a>2. Tagged Pointer 介绍</h3><p>为了改进上面提到的内存占用和效率问题，苹果提出了 Tagged Pointer 对象。将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址，64 位 CPU 下 NSNumber 的内存图变成下面这样：</p>
<p><img src="/img/img024.jpg" alt="image024"></p>
<h3 id="3-Tagged-Pointer-特点"><a href="#3-Tagged-Pointer-特点" class="headerlink" title="3. Tagged Pointer 特点"></a>3. Tagged Pointer 特点</h3><ol>
<li>Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和 NSDate；</li>
<li>Tagged Pointer 指针的值不再是地址，而是真正的值。所以实际上它不再是一个对象了，只是一个披着对象“皮”的普通变量而已，所以，它的内存并不存储在堆中；</li>
<li>在内存读取上有着以前 3 倍的效率，创建时比以前快 106 倍。</li>
</ol>
<h3 id="4-引用计数相关变化"><a href="#4-引用计数相关变化" class="headerlink" title="4. 引用计数相关变化"></a>4. 引用计数相关变化</h3><p>在 32 位环境下，对象的引用计数都保存在一个外部的表中，每一个对象的 Retain 操作，实际包括如下 5 个步骤：</p>
<ol>
<li>获得全局的记录引用计数的 hash 表；</li>
<li>为了线程安全，给该 hash 表加锁；</li>
<li>查找到目标对象的引用计数值；</li>
<li>将该引用计数值加 1，写回 hash 表；</li>
<li>给该 hash 表解锁。</li>
</ol>
<p>而在 64 位环境下，isa 指针也是 64 位，实际作为指针部分只用到其中 33 位，剩余的 31 位苹果使用了类似 Tagged Pointer 的概念，其中 19 位将保存对象的引用计数，这样对引用计数的操作只需要修改这个指针即可。只有当引用计数超出 19 位，才会将引用计数保存到外部表，但是这种情况是很少的。在 64 位环境下，新的 Retain 操作包括如下 5 个步骤：</p>
<ol>
<li>检查 isa 指针上面的标记位，看引用计数是否保存在 isa 变量中，如果不是，则使用以前的步骤，否则执行第 2 步；</li>
<li>检查当前对象是否正在释放，如果是，不做任何事情；</li>
<li>增加该对象的引用计数，但是并不马上写回到 isa 变量中；</li>
<li>检查增加后的引用计数的值是否能够被 19 位表示，如果不是，则切换成以前的办法，否则执行第 5 步；</li>
<li>进行一个原子的写操作，将 isa 的值写回。</li>
</ol>
<p>虽然步骤都是 5 步，但是由于没有了全局的加锁操作，所以引用计数的更改更快了。</p>
<h3 id="5-isa-的-bit-位含义"><a href="#5-isa-的-bit-位含义" class="headerlink" title="5. isa 的 bit 位含义"></a>5. isa 的 bit 位含义</h3><table>
<thead>
<tr>
<th>bit 位</th>
<th>变量名</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 bit</td>
<td>indexed</td>
<td>0 表示普通的 isa，1 表示 Tagged Pointer</td>
</tr>
<tr>
<td>1 bit</td>
<td>has_assoc</td>
<td>表示该对象是否有过 associated 对象，如果没有，在析构释放内存时可以更快</td>
</tr>
<tr>
<td>1 bit</td>
<td>has_cxx_dtor</td>
<td>表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，在析构释放内存时可以更快</td>
</tr>
<tr>
<td>30 bits</td>
<td>shiftcls</td>
<td>类的指针</td>
</tr>
<tr>
<td>9 bits</td>
<td>magic</td>
<td>其值固定为 0xd2，用于在调试时分辨对象是否未完成初始化</td>
</tr>
<tr>
<td>1 bit</td>
<td>weakly_referenced</td>
<td>表示该对象是否有过 weak 对象，如果没有，在析构释放内存时可以更快 </td>
</tr>
<tr>
<td>1 bit</td>
<td>deallocating</td>
<td>表示该对象是否正在析构</td>
</tr>
<tr>
<td>1 bit</td>
<td>has_sidetable_rc</td>
<td>表示该对象的引用计数值是否大到无法直接在 isa 中保存</td>
</tr>
<tr>
<td>19 bits</td>
<td>extra_rc</td>
<td>表示该对象超过 1 的引用计数值，例如，如果该对象的引用计数是 6，则 extra_rc 的值为 5 </td>
</tr>
</tbody>
</table>
<h2 id="十三、block-对象模型"><a href="#十三、block-对象模型" class="headerlink" title="十三、block 对象模型"></a>十三、block 对象模型</h2><h3 id="1-block-内部数据结构定义"><a href="#1-block-内部数据结构定义" class="headerlink" title="1. block 内部数据结构定义"></a>1. block 内部数据结构定义</h3><p>从苹果的 LLVM 项目的<a href="https://llvm.org/svn/llvm-project/compiler-rt/tags/Apple/Libcompiler_rt-10/BlocksRuntime/Block_private.h" target="_blank" rel="noopener">开源代码</a>中可以得到 block 数据结构定义，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_descriptor &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved; </span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor *descriptor;</span><br><span class="line">    <span class="comment">/* Imported variables. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个 block 实例由 6 部分构成：</p>
<ol>
<li>isa 指针</li>
<li>flags，用于按 bit 位表示一些 block 的附加信息 </li>
<li>reserved，保留变量</li>
<li>invoke，函数指针，指向具体的 block 实现的函数调用地址</li>
<li>descriptor，表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针</li>
<li>variables，capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。</li>
</ol>
<h3 id="2-block-三种类型"><a href="#2-block-三种类型" class="headerlink" title="2. block 三种类型"></a>2. block 三种类型</h3><ul>
<li>_NSConcreteGlobalBlock，全局的静态 block，不会访问任何外部变量；</li>
<li>_NSConcreteStackBlock，保存在栈中的 block，当函数返回时会被销毁；</li>
<li>_NSConcreteMallocBlock，保存在堆中的 block，当引用计数为 0 时会被销毁。</li>
</ul>
<h4 id="NSGlobalBlock"><a href="#NSGlobalBlock" class="headerlink" title="NSGlobalBlock"></a>NSGlobalBlock</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(^myBlock)() = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hello world"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, myBlock);  <span class="comment">// &lt;__NSGlobalBlock__: 0x10d65b240&gt;</span></span><br></pre></td></tr></table></figure>
<p>对 NSGlobalBlock 的 retain、copy、release 操作都无效。</p>
<h4 id="NSStackBlock-和-NSMallocBlock"><a href="#NSStackBlock-和-NSMallocBlock" class="headerlink" title="NSStackBlock 和 NSMallocBlock"></a>NSStackBlock 和 NSMallocBlock</h4><p>在 MRC 模式下打印：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span>(^myBlock)() = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"malloc block and num = %d"</span>, num);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, myBlock);  <span class="comment">// &lt;__NSStackBlock__: 0x7fff574d5a08&gt;</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">block 在函数退出的时候，就会被回收，如果再调用该 block 会导致 crash</span><br><span class="line"></span><br><span class="line">在 ARC 模式下打印：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span>(^myBlock)() = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"malloc block and num = %d"</span>, num);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, myBlock);  <span class="comment">// &lt;__NSMallocBlock__: 0x600000048220&gt;</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这里为什么打印的是 <span class="built_in">NSMallocBlock</span> 呢？在 ARC 模式下生成的 block 也是 <span class="built_in">NSStackBlock</span>，只是当赋值给 <span class="keyword">strong</span> 对象时，系统会主动对其进行 <span class="keyword">copy</span>，将栈上复制到堆上。如果不赋值，直接打印，则为 <span class="built_in">NSStackBlock</span>   </span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hello world and num = %d"</span>, num);</span><br><span class="line">&#125;);  <span class="comment">// &lt;__NSStackBlock__: 0x7fff574d5a08&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="11-3-循环引用"><a href="#11-3-循环引用" class="headerlink" title="11.3 循环引用"></a>11.3 循环引用</h3><ol>
<li>在 MRC 时代，<strong>block 修饰避免循环引用；ARC 时代，</strong>block 修饰同样会引起循环引用；</li>
<li>不用 <strong>block 修饰，block 外的变量引用，是复制其本身；使用 </strong>block 修饰，block 外的变量引用，是复制其引用地址；</li>
<li><strong>block 不管是 ARC 还是 MRC 模式下都可以修饰对象和基本数据类型；</strong>weak 只能在 ARC 模式下使用，也只能修饰对象，不能修饰基本数据类型；</li>
<li><strong>block 对象可以在 block 中被重新赋值，</strong>weak 不可以。</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>2017-04-27 一次阅读</p>
<p>前前后后大概半个月，利用零碎时间看完了这本书。这本书前年就有所耳闻，网上的评价也褒贬不一，唐巧写的相对来说，语言通俗易懂，感觉像是博客一样，没有什么限制，读起来很畅快。这本书适合初学者，虽然大部分内容之前都已经熟悉掌握，但是看过一遍还是很有收获的，有些知识点的总结很到位，感觉没有浪费时间。遗留的问题是 CoreText 部分内容打算结合其他资料系统的研究一下，这里就先不仔细阅读了。</p>
<p>2018-01-19 二次阅读 </p>
<p>大概三天时间通读了一遍，又有一点点收获吧，模糊的概念捋顺了一遍，总体来说内容很简单，用不到的功能还是没有细看，比如内购、CoreText 等等模块。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/22/【iOS】多线程编程总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mayan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mayan`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/22/【iOS】多线程编程总结/" itemprop="url">【iOS】多线程编程总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-22T12:56:31+08:00">
                2016-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/22/【iOS】多线程编程总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/12/22/【iOS】多线程编程总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是执行程序最基本的单元，它有自己栈和寄存器。说得再具体一些，线程就是一个 CPU 执行的一条无分叉的命令列。对于多线程，其中每一条线程都会有自己的栈和寄存器。</p>
<h3 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h3><ul>
<li>能适当提高程序的执行效率</li>
<li>能适当提高资源利用率（CPU、内存利用率）</li>
</ul>
<h3 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h3><ul>
<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用 1M，子线程占用 512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>线程越多，CPU 在调度线程上的开销就越大</li>
<li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>
</ul>
<h3 id="多线程实际应用"><a href="#多线程实际应用" class="headerlink" title="多线程实际应用"></a>多线程实际应用</h3><ul>
<li>单例模式</li>
<li>耗时操作（数据库读写、处理音视频数据）</li>
<li>接口请求数据</li>
</ul>
<h3 id="iOS-开发中的多线程"><a href="#iOS-开发中的多线程" class="headerlink" title="iOS 开发中的多线程"></a>iOS 开发中的多线程</h3><table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>线程生命周期</th>
<th>使用频率</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread</td>
<td>跨平台、使用难度大</td>
<td>程序员管理线程</td>
<td>几乎不用</td>
</tr>
<tr>
<td>NSThread</td>
<td>更加面向对象、简单易用、直接操作线程对象</td>
<td>程序员管理线程</td>
<td>偶尔使用</td>
</tr>
<tr>
<td>GCD</td>
<td>代替 NSThread、充分利用设备多核</td>
<td>自动管理线程</td>
<td>经常使用</td>
</tr>
<tr>
<td>NSOperation</td>
<td>基于 GCD、更加面向对象</td>
<td>自动管理线程</td>
<td>经常使用</td>
</tr>
</tbody>
</table>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>GCD（Grand Central Dispatch，牛逼的中枢调度器）是 iOS 4.0 引入的多线程编程技术，其有两个核心的概念：队列和执行方式。GCD 以 block 为基本单位，一个 block 中的代码可以作为一个任务，使用 block 的过程，就是把 block 放进合适的队列（串行 / 并行），并选择合适的执行方式（同步 / 异步）去执行。</p>
<h3 id="1-内部管理线程的优点"><a href="#1-内部管理线程的优点" class="headerlink" title="1. 内部管理线程的优点"></a>1. 内部管理线程的优点</h3><p>当使用 GCD 的时候，你不用考虑线程方面的问题，只需考虑队列和任务。举个例子，如果我们直接使用线程，想要做一些并发的事情。我们可能把我们的任务分成 N 个小任务，同时创建 8 个线程，把这些小任务分别送到这 8 个线程中。但是这些小任务中会有一些三方函数，写这个函数的人同时也想要使用并发，可能同样会创建 8 个线程。所以，现在会同时创建 8 x 8 = 64 个线程。使用 GCD 就不会有这种问题，GCD 严格来说不是开一条线程，而是从池中获取。比如串行队列除了主队列外，每次执行任务都会获取一条线程。一个任务执行完毕后线程是会回到池，直到再次被唤起。而实际上当没有其它对手抢占了这条刚回到池中的线程时，同一个串行队列会继续获取到这条相同的线程执行下一个任务。</p>
<h3 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2. 核心概念"></a>2. 核心概念</h3><ul>
<li>同步执行（sync）：会阻塞当前线程，并等待 block 中的任务执行完毕，然后当前线程才会继续往下运行。</li>
<li>异步执行（async）：不会阻塞当前线程，当前线程会直接往下进行。</li>
<li>串行队列（Serial Dispatch Queue）：任务先进先出，顺次执行，每次只执行一个任务。</li>
<li>并行队列（Concurrent Dispatch Queue）：任务依然是先进先出，但是形成多个任务并发，这样看起来都是一起执行的。</li>
</ul>
<p>串行和并行针对的是队列（Dispatch Queue），同步和异步针对的是线程。</p>
<h3 id="3-同步执行-异步执行-amp-串行队列-并行队列"><a href="#3-同步执行-异步执行-amp-串行队列-并行队列" class="headerlink" title="3. 同步执行 / 异步执行 &amp; 串行队列 / 并行队列"></a>3. 同步执行 / 异步执行 &amp; 串行队列 / 并行队列</h3><ul>
<li><p>同步执行 &amp; 串行队列 —— 当前线程阻塞，并在当前线程一个一个执行，没有意义，在特定情况下还会造成死锁，略。</p>
</li>
<li><p>同步执行 &amp; 并行队列 —— 当前线程阻塞，开启多条线程一个一个执行，还会存在切换线程的耗时，同样没有意义，略。</p>
</li>
<li><p>异步执行 &amp; 串行队列 —— 当前线程不阻塞，开启一条线程一个一个执行。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mayan29.queue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 A, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 B, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 C, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// 执行任务 A, 线程 &lt;NSThread: 0x60000026bcc0&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 执行任务 B, 线程 &lt;NSThread: 0x60000026bcc0&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 执行任务 C, 线程 &lt;NSThread: 0x60000026bcc0&gt;&#123;number = 3, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>异步执行 &amp; 并行队列 —— 当前线程不阻塞，开启多条线程同时执行。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mayan29.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 A, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 B, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 C, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// 执行任务 B, 线程 &lt;NSThread: 0x6000002783c0&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 执行任务 C, 线程 &lt;NSThread: 0x60400027a6c0&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 执行任务 A, 线程 &lt;NSThread: 0x600000277800&gt;&#123;number = 3, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-死锁问题"><a href="#4-死锁问题" class="headerlink" title="4. 死锁问题"></a>4. 死锁问题</h3><p>在使用 GCD 的过程中，如果向当前串行队列中同步派发一个任务，就会导致死锁。比如下面两段代码都会导致死锁：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务 A"</span>);</span><br><span class="line">&#125;);    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务 B"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mayan29.queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务 A"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务 B"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>程序遇到了同步线程，那么它会进入等待，等待任务 A 执行完，然后执行任务 B。但对于串行队列，有任务来就会将任务加到队尾，然后遵循 FIFO 原则执行任务。那么，现在任务 A 就会被加到最后，任务 B 排在了任务 A 前面，那么问题来了：</p>
<p>任务 B 要等任务 A 执行完才能执行，任务 A 又排在任务 B 后面，意味着任务 A 要在任务 B 执行完才能执行，所以他们进入了互相等待的局面，这就是死锁。</p>
<p>其实在通常情况下我们不必要用 dispatch_sync，因为 dispatch_async 能够更好的利用 CPU，提升程序运行速度。只有当我们需要保证队列中的任务必须顺序执行时，才考虑使用 dispatch_sync。在使用 dispatch_sync 的时候应该分析当前处于哪个队列，以及任务会提交到哪个队列。 </p>
<h3 id="5-任务组"><a href="#5-任务组" class="headerlink" title="5. 任务组"></a>5. 任务组</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mayan29.queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 A 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 B 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 C 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务全部执行完毕"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mayan29.queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 A, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 B, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 C, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 2 秒，如果是不限时间可改为 DISPATCH_TIME_FOREVER</span></span><br><span class="line"><span class="keyword">long</span> result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务全部执行完成"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务正在处理"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务全部执行完毕"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// 执行任务 A, 线程 &lt;NSThread: 0x60400026f4c0&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 执行任务 B, 线程 &lt;NSThread: 0x60400026f4c0&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 任务正在处理</span></span><br><span class="line"><span class="comment">// 执行任务 C, 线程 &lt;NSThread: 0x60400026f4c0&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 任务全部执行完毕</span></span><br></pre></td></tr></table></figure>
<h3 id="6-栅栏函数"><a href="#6-栅栏函数" class="headerlink" title="6. 栅栏函数"></a>6. 栅栏函数</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mayan29.queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 A 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 B 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务 A 和 B 执行完毕，即将执行任务 C"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 C 任务"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="7-Apply-循环执行"><a href="#7-Apply-循环执行" class="headerlink" title="7. Apply 循环执行"></a>7. Apply 循环执行</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = @[<span class="string">@"执行 A 任务"</span>, <span class="string">@"执行 B 任务"</span>, <span class="string">@"执行 C 任务"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    dispatch_apply(arr.count, queue, ^(size_t index) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, arr[index]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务全部执行完毕"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="8-队列唤醒-amp-挂起"><a href="#8-队列唤醒-amp-挂起" class="headerlink" title="8. 队列唤醒 &amp; 挂起"></a>8. 队列唤醒 &amp; 挂起</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mayan29.queue"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行 A 任务"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_suspend(queue);  <span class="comment">// 挂起</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_resume(queue);  <span class="comment">// 唤醒，执行任务 A</span></span><br></pre></td></tr></table></figure>
<h3 id="9-信号量"><a href="#9-信号量" class="headerlink" title="9. 信号量"></a>9. 信号量</h3><p>其实最经典的例子就是批量下载。比如有 N 个图片需要一个一个下载，但是需要控制每次只能下载 3 个，就需要用到信号量了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 A"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 B"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 C"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 D"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>), ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 E"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务全部执行完毕"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">打印结果</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-21</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">44.447412</span>+<span class="number">0800</span> GCD[<span class="number">15452</span>:<span class="number">5524785</span>] 下载图片 C</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-21</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">44.447412</span>+<span class="number">0800</span> GCD[<span class="number">15452</span>:<span class="number">5524781</span>] 下载图片 A</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-21</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">44.447412</span>+<span class="number">0800</span> GCD[<span class="number">15452</span>:<span class="number">5524782</span>] 下载图片 B</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-21</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">46.449871</span>+<span class="number">0800</span> GCD[<span class="number">15452</span>:<span class="number">5524784</span>] 下载图片 D</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-21</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">46.449866</span>+<span class="number">0800</span> GCD[<span class="number">15452</span>:<span class="number">5524783</span>] 下载图片 E</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-21</span> <span class="number">16</span>:<span class="number">56</span>:<span class="number">48.455010</span>+<span class="number">0800</span> GCD[<span class="number">15452</span>:<span class="number">5524743</span>] 任务全部执行完毕</span><br></pre></td></tr></table></figure>
<h3 id="10-定时器"><a href="#10-定时器" class="headerlink" title="10. 定时器"></a>10. 定时器</h3><p>GCD 定时器不受 RunLoop 中 Mode 的影响（RunLoop 内部也是基于 GCD 实现的)，比如滚动 TableView 的时候，GCD 的定时器不受影响。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 间隔 1 秒，并允许有 0.1 秒的误差</span></span><br><span class="line">dispatch_source_set_timer(<span class="keyword">self</span>.timer, DISPATCH_TIME_NOW, <span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 10 秒之后停止</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">10</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        dispatch_cancel(<span class="keyword">self</span>.timer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时器</span></span><br><span class="line">dispatch_resume(<span class="keyword">self</span>.timer);</span><br></pre></td></tr></table></figure>
<h3 id="11-单例模式"><a href="#11-单例模式" class="headerlink" title="11. 单例模式"></a>11. 单例模式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (Manager *)sharedInstance &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Manager *sharedManagerInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedManagerInstance = [[Manager alloc] init];</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sharedManagerInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p>从简单意义上来说，NSOperation 就是对 GCD 中的 block 进行的封装。相对 GCD 来说，使用 NSOperation 会增加一点点额外的开销，但是我们却换来了非常强大的灵活性和功能，我们可以给 operation 之间添加依赖关系、取消一个正在执行的 operation、暂停和恢复 operation queue 等。并且它有三种状态 isExecuted、isFinished 和 isCancelled 以方便我们通过 KVC 对它的状态进行监听。</p>
<h3 id="1-创建多线程"><a href="#1-创建多线程" class="headerlink" title="1. 创建多线程"></a>1. 创建多线程</h3><p>NSOperation 是一个基类，不应该直接生成 NSOperation 对象，而是应该用它的子类 NSBlockOperation 或者 NSInvocationOperation，两种方式本质没有区别。</p>
<h4 id="标准创建"><a href="#标准创建" class="headerlink" title="标准创建"></a>标准创建</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建操作</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 A, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[operation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 B, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[operation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 C, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加操作到队列，自动异步执行</span></span><br><span class="line">[queue addOperation:operation];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// 执行任务 B, 线程 &lt;NSThread: 0x6000002783c0&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 执行任务 A, 线程 &lt;NSThread: 0x600000277800&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 执行任务 C, 线程 &lt;NSThread: 0x60400027a6c0&gt;&#123;number = 5, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="快速创建"><a href="#快速创建" class="headerlink" title="快速创建"></a>快速创建</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 A, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 B, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行任务 C, 线程 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// 执行任务 B, 线程 &lt;NSThread: 0x60400026eb80&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 执行任务 C, 线程 &lt;NSThread: 0x600000273700&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 执行任务 A, 线程 &lt;NSThread: 0x60400007c500&gt;&#123;number = 4, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-最大并发数-amp-依赖关系"><a href="#2-最大并发数-amp-依赖关系" class="headerlink" title="2. 最大并发数 &amp; 依赖关系"></a>2. 最大并发数 &amp; 依赖关系</h3><p>用 NSOperation 模仿一下 GCD 的信号量 &amp; 任务组。可能是我没有理解到位？反正我还是感觉 GCD 最好用，清晰明了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. 限制每次最多并发 3 个</span></span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. 创建操作</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operationA = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 A"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operationB = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 B"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operationC = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 C"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operationD = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 D"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operationE = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 E"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operationEnd = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务全部执行完毕"</span>);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3. 添加操作到队列，自动异步执行</span></span><br><span class="line">[queue addOperation:operationA];</span><br><span class="line">[queue addOperation:operationB];</span><br><span class="line">[queue addOperation:operationC];</span><br><span class="line">[queue addOperation:operationD];</span><br><span class="line">[queue addOperation:operationE];</span><br><span class="line">[queue addOperation:operationEnd];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 4. 添加所有依赖</span></span><br><span class="line">[operationEnd addDependency:operationA];</span><br><span class="line">[operationEnd addDependency:operationB];</span><br><span class="line">[operationEnd addDependency:operationC];</span><br><span class="line">[operationEnd addDependency:operationD];</span><br><span class="line">[operationEnd addDependency:operationE];</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">16.295008</span>+<span class="number">0800</span> GCD[<span class="number">35716</span>:<span class="number">6312067</span>] 下载图片 A</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">16.295008</span>+<span class="number">0800</span> GCD[<span class="number">35716</span>:<span class="number">6312068</span>] 下载图片 C</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">16.295008</span>+<span class="number">0800</span> GCD[<span class="number">35716</span>:<span class="number">6312069</span>] 下载图片 B</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">18.298938</span>+<span class="number">0800</span> GCD[<span class="number">35716</span>:<span class="number">6312068</span>] 下载图片 E</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">18.298903</span>+<span class="number">0800</span> GCD[<span class="number">35716</span>:<span class="number">6312070</span>] 下载图片 D</span><br><span class="line"><span class="number">2016</span><span class="number">-12</span><span class="number">-22</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">20.301242</span>+<span class="number">0800</span> GCD[<span class="number">35716</span>:<span class="number">6312070</span>] 任务全部执行完毕</span><br></pre></td></tr></table></figure>
<h3 id="3-其他方法"><a href="#3-其他方法" class="headerlink" title="3. 其他方法"></a>3. 其他方法</h3><h4 id="NSOperation-方法"><a href="#NSOperation-方法" class="headerlink" title="NSOperation 方法"></a>NSOperation 方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled)  <span class="built_in">BOOL</span> cancelled;   <span class="comment">// 判断任务是否取消</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting)  <span class="built_in">BOOL</span> executing;   <span class="comment">// 判断任务是否正在执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinished)   <span class="built_in">BOOL</span> finished;    <span class="comment">// 判断任务是否完成</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isConcurrent) <span class="built_in">BOOL</span> concurrent;  <span class="comment">// 判断任务是否并行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^completionBlock)();  <span class="comment">// 完成后需要执行的操作</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSOperationQueuePriority</span> queuePriority;  <span class="comment">// 优先级</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancel;  <span class="comment">// 取消任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilFinished;  <span class="comment">// 阻塞当前线程直到此任务执行完毕</span></span><br></pre></td></tr></table></figure>
<h4 id="NSOperation-Queue-方法"><a href="#NSOperation-Queue-方法" class="headerlink" title="NSOperation Queue 方法"></a>NSOperation Queue 方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">getter</span>=isSuspended) <span class="built_in">BOOL</span> suspended;  <span class="comment">// YES，暂停；NO，恢复队列</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations;  <span class="comment">// 取消队列中所有任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilAllOperationsAreFinished;  <span class="comment">// 阻塞当前线程直到此队列中所有任务执行完毕</span></span><br></pre></td></tr></table></figure>
<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p>这套方案是经过苹果封装后的，并且完全面向对象的，所以可以直接操控线程对象，非常直观和方便。但是，它的生命周期还是需要我们手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]。</p>
<h3 id="1-创建多线程-1"><a href="#1-创建多线程-1" class="headerlink" title="1. 创建多线程"></a>1. 创建多线程</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准创建</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download) object:<span class="literal">nil</span>];</span><br><span class="line">[thread start];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速创建</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(download) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式创建</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(download) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<h3 id="2-其他方法"><a href="#2-其他方法" class="headerlink" title="2. 其他方法"></a>2. 其他方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断某个线程的状态的属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="built_in">BOOL</span> executing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinished)  <span class="built_in">BOOL</span> finished;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="built_in">BOOL</span> cancelled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程 / 获取主线程</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *currentThread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> *mainThread;</span><br><span class="line"><span class="comment">// 当前线程是否是主线程</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> isMainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消线程</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使当前线程暂停 N 秒</span></span><br><span class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date;</span><br><span class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制关闭线程</span></span><br><span class="line">+ (<span class="keyword">void</span>)exit;</span><br></pre></td></tr></table></figure>
<h3 id="3-线程加锁"><a href="#3-线程加锁" class="headerlink" title="3. 线程加锁"></a>3. 线程加锁</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    </span><br><span class="line">    _ticketNum = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    _thread_1 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicket) object:<span class="literal">nil</span>];</span><br><span class="line">    _thread_2 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicket) object:<span class="literal">nil</span>];</span><br><span class="line">    _thread_3 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicket) object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    _thread_1.name = <span class="string">@"一号窗口"</span>;</span><br><span class="line">    _thread_2.name = <span class="string">@"二号窗口"</span>;</span><br><span class="line">    _thread_3.name = <span class="string">@"三号窗口"</span>;</span><br><span class="line">    </span><br><span class="line">    [_thread_1 start];</span><br><span class="line">    [_thread_2 start];</span><br><span class="line">    [_thread_3 start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)saleTicket &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;  <span class="comment">// 加锁</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (_ticketNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                _ticketNum --;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@卖了一张票，剩余%d张票"</span>, [<span class="built_in">NSThread</span> currentThread].name, _ticketNum);</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>;  <span class="comment">// 退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;  <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.jianshu.com/p/201ccb40a3f8" target="_blank" rel="noopener">一篇专题让你秒懂 GCD 死锁问题</a></li>
<li><a href="https://bestswifter.com/multithreadconclusion/#" target="_blank" rel="noopener">iOS 多线程编程总结</a></li>
<li><a href="http://www.cocoachina.com/industry/20130821/6842.html" target="_blank" rel="noopener">Objective-C 的底层并发 API</a></li>
<li><a href="http://www.cnblogs.com/kenshincui/p/3983982.html" target="_blank" rel="noopener">iOS 开发系列 – 并行开发其实很容易</a></li>
<li><a href="https://www.jianshu.com/p/0b0d9b1f1f19" target="_blank" rel="noopener">关于 iOS 多线程，你看我就够了</a></li>
<li><a href="https://www.jianshu.com/p/95aa5446361d" target="_blank" rel="noopener">iOS 开发之多线程编程总结（一）</a></li>
<li><a href="https://www.jianshu.com/p/2a614531187f" target="_blank" rel="noopener">iOS 开发之多线程编程总结（二）</a></li>
<li><a href="https://www.jianshu.com/p/01a9b8c9e963" target="_blank" rel="noopener">iOS 开发之多线程编程总结（三）</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpeg"
                alt="mayan" />
            
              <p class="site-author-name" itemprop="name">mayan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/mayan29" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:18511560993@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mayan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://mayan29.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
