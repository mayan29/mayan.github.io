<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="作者：Matt Galloway 出版日期：2014-1 豆瓣地址：https://book.douban.com/subject/25829244/  1. 了解 Objective-C 语言OC 使用消息结构（messaging structure）而不是函数调用（function calling），写法如下： 123// Objective-CObject *obj = [Object n">
<meta property="og:type" content="article">
<meta property="og:title" content="【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》">
<meta property="og:url" content="http://yoursite.com/2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/index.html">
<meta property="og:site_name" content="mayan`s blog">
<meta property="og:description" content="作者：Matt Galloway 出版日期：2014-1 豆瓣地址：https://book.douban.com/subject/25829244/  1. 了解 Objective-C 语言OC 使用消息结构（messaging structure）而不是函数调用（function calling），写法如下： 123// Objective-CObject *obj = [Object n">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/img/img025.png">
<meta property="og:image" content="http://yoursite.com/img/img026.jpg">
<meta property="og:image" content="http://yoursite.com/img/img027.png">
<meta property="og:image" content="http://yoursite.com/img/img028.png">
<meta property="og:updated_time" content="2018-06-25T14:49:03.488Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》">
<meta name="twitter:description" content="作者：Matt Galloway 出版日期：2014-1 豆瓣地址：https://book.douban.com/subject/25829244/  1. 了解 Objective-C 语言OC 使用消息结构（messaging structure）而不是函数调用（function calling），写法如下： 123// Objective-CObject *obj = [Object n">
<meta name="twitter:image" content="http://yoursite.com/img/img025.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/"/>





  <title>【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》 | mayan`s blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mayan`s blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mayan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mayan`s blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-05T16:36:42+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>作者：Matt Galloway</p>
<p>出版日期：2014-1</p>
<p>豆瓣地址：<a href="https://book.douban.com/subject/25829244/" target="_blank" rel="noopener">https://book.douban.com/subject/25829244/</a></p>
</blockquote>
<h2 id="1-了解-Objective-C-语言"><a href="#1-了解-Objective-C-语言" class="headerlink" title="1. 了解 Objective-C 语言"></a>1. 了解 Objective-C 语言</h2><p>OC 使用<code>消息结构</code>（messaging structure）而不是<code>函数调用</code>（function calling），写法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C</span></span><br><span class="line">Object *obj = [Object new];</span><br><span class="line">[obj performWith: parameter1 and: parameter2];</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line">Object *obj = <span class="keyword">new</span> Object;</span><br><span class="line">obj-&gt;perform(parameter1, parameter2);</span><br></pre></td></tr></table></figure>
<p>使用消息结构的语言，运行时执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。如果调用的函数是多态的，那么在运行时就要按照<code>虚方法表</code>（virtual table）来查出到底应该执行哪个函数实现。而消息结构的语言，不论是否多态，总是在运行时才会去查找所要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，其过程叫做<code>动态绑定</code>（dynamic binding）。</p>
<p>Objective-C 的重要工作都由 runtime 组件而非编译器来完成，所需的全部数据结构和函数都在 runtime 组件里面，runtime 组件含有全部内存管理方法。runtime 本质上就是一种与开发者编写的代码相链接的<code>动态库</code>（dynamic library），其代码能把开发者编写的所有程序粘合起来。</p>
<h2 id="2-在类的头文件中尽量少引入其他头文件"><a href="#2-在类的头文件中尽量少引入其他头文件" class="headerlink" title="2. 在类的头文件中尽量少引入其他头文件"></a>2. 在类的头文件中尽量少引入其他头文件</h2><p>与 C 和 C++ 一样，OC 也使用<code>头文件</code>（header file）和<code>实现文件</code>（implementation file）来区隔代码。用 OC 编写的任何类几乎都需要引入 <code>Foundation.h</code>，如果包含 UI 控件，需要引入 <code>UIKit.h</code></p>
<p>一般来说，应在某个类的头文件中使用<code>前向声明</code>（forward declaring）来提及别的类，这样做可以尽量降低类之间的耦合。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">MYPerson</span>;</span></span><br></pre></td></tr></table></figure>
<p>循环引用（chicken-and-egg situation）：如果在各自头文件中引入对方的头文件，当解析其中一个头文件时，编译器会发现它引入了另一个头文件，而那个头文件又回过头来引用第一个头文件。使用 #import 而非 #include 指令虽然不会导致死循环，但是却意味着两个类里有一个无法被正确编译。</p>
<h2 id="3-多用字面量语法，少用与之等价的方法"><a href="#3-多用字面量语法，少用与之等价的方法" class="headerlink" title="3.多用字面量语法，少用与之等价的方法"></a>3.多用字面量语法，少用与之等价的方法</h2><p>使用<code>字面量语法</code>（literal syntax）的好处是可以缩减源代码长度，使其更为易读。其本质为一种<code>语法糖</code>（syntactic sugar），以数组为例，其效果等于是先创建一个数组，然后把方括号里的所有对象都加到这个数组中。但是数组元素中不能有 nil，因为 arrayWithObjects: 方法会依次处理各个参数，直到发现 nil 为止，如果中间元素是 nil，该方法会提前结束。这个问题同样适用于字典。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h2 id="4-多用类型常量，少用-define-预处理指令"><a href="#4-多用类型常量，少用-define-预处理指令" class="headerlink" title="4.多用类型常量，少用 #define 预处理指令"></a>4.多用类型常量，少用 #define 预处理指令</h2><p>比如想把播放动画的时间提取为常量，使用预处理指令，也就是宏定义可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ANIMATION_DURATION 0.3</span></span><br></pre></td></tr></table></figure>
<p>上面的宏定义的缺点是，这样定义出来的常量没有类型信息，此外会把碰到的所有 ANIMATION_DURATION 一律替换成 0.3</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<p>上面的方式定义的常量包含类型信息，其好处是清楚的描述了常量的含义。需要注意的是，如果常量局限于 .m 文件中，则在前面加字母 k；若常量在类之外可见，通常以类名为前缀，比如 MYViewAnimationDuration。</p>
<p>static 作用：假如声明此变量时不加 static，则编译器会为它创建一个外部符号，此时若是另一个实现文件也声明了同名变量，那么编译器会报错。</p>
<p>如果需要对外公开某个常量，可以声明为一个外界可见的常值变量，外界无需知道实际常量值，只需知道常量名称即可，此类常量需放在<code>全局符号表</code>（global symbol table）中，如下定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> MYStringConstant;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> MYStringConstant = <span class="string">@"VALUE"</span>;</span><br></pre></td></tr></table></figure>
<p>编译器看到头文件中的 extern 关键字，无需查看其定义，即允许代码使用此常量。因为它知道，当链接成二进制文件之后，肯定能找到这个常量。</p>
<p>此类常量必须定义，并且只能定义一次，由实现文件生成目标文件时，编译器会在<code>数据段</code>（data section）为字符串分配存储空间。链接器会把此目标文件与其他目标文件相链接，以生成最终的二进制文件。凡是用到 MYStringConstant 这个全局符号的地方，链接器都能将其解析。</p>
<p>前例中的动画播放时长对外公布，可以这样声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> MYViewAnimationDuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> MYViewAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<h2 id="5-用枚举表示状态、选项、状态码"><a href="#5-用枚举表示状态、选项、状态码" class="headerlink" title="5. 用枚举表示状态、选项、状态码"></a>5. 用枚举表示状态、选项、状态码</h2><p>C++11 标准修订了枚举的某些特性，其中一项改动就是：可以指明用何种<code>底层数据类型</code>（underlying type）来保存枚举类型的变量，这样做的好处是，可以向前声明枚举变量了。若不指定底层数据类型，编译器不清楚底层数据类型的大小，所以在用到此枚举类型时，就不知道究竟该给变量分配多少空间。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> MYConnectionState : <span class="built_in">NSUInteger</span> &#123;</span><br><span class="line">    MYConnectionStateDisconnected,</span><br><span class="line">    MYConnectionStateConnecting,</span><br><span class="line">    MYConnectionStateConnected</span><br><span class="line">&#125; MYConnectionState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, MYConnectionState) &#123;</span><br><span class="line">    MYConnectionStateDisconnected,</span><br><span class="line">    MYConnectionStateConnecting,</span><br><span class="line">    MYConnectionStateConnected</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MYConnectionState state = MYConnectionStateConnecting;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> MYConnectionState : <span class="built_in">NSUInteger</span> &#123;</span><br><span class="line">    MYConnectionStateDisconnected = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    MYConnectionStateConnecting   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    MYConnectionStateConnected    = <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line">&#125; MYConnectionState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, MYConnectionState) &#123;</span><br><span class="line">    MYConnectionStateDisconnected = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    MYConnectionStateConnecting   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    MYConnectionStateConnected    = <span class="number">1</span> &lt;&lt; <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MYConnectionState state = MYConnectionStateDisconnected | MYConnectionStateConnecting;</span><br></pre></td></tr></table></figure>
<h2 id="6-理解属性这一概念"><a href="#6-理解属性这一概念" class="headerlink" title="6. 理解属性这一概念"></a>6. 理解属性这一概念</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MYPerson</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSString</span> *_firstName;</span><br><span class="line">	<span class="built_in">NSString</span> *_lastName;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>以上写法一般是 Java 和 C++ 的写法，而 Objective-C 代码却很少这么做。这种写法的问题是：对象布局在<code>编译期</code>（compile time）就已经固定了。只要碰到访问 <code>_fistName</code> 变量的代码，编译器就把其替换为<code>偏移量</code>（offset），这个偏移量是<code>硬编码</code>（hardcode），表示该变量距离存放对象的内存区域的起始地址有多远。这样做目前来看没有问题，但是如果又加了一个实例变量，那就麻烦了。比如在 <code>_firstName</code> 之前又多了一个实例变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MYPerson</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSString</span> *_dateOfBirth;</span><br><span class="line">	<span class="built_in">NSString</span> *_firstName;</span><br><span class="line">	<span class="built_in">NSString</span> *_lastName;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>原来表示 <code>_firstName</code> 的偏移量现在却指向 <code>_dataOfBirth</code>，把偏移量硬编码于其中的那些代码都会读取到错误的值</p>
<p><img src="/img/img025.png" alt="image025"></p>
<p>如果代码使用了编译期间计算出来的偏移量，那么在修改类定义之后必须重新编译，否则就会出错。</p>
<p>Objective-C 的做法是，把实例变量当做一种存储偏移量所用的<code>特殊变量</code>（special variable），交由<code>类对象</code>（class object）保管，偏移量会在运行期查找，如果类的定义变了，那么存储的偏移量也就变了，所以总能使用正确的偏移量，甚至可以在运行期向类中新增实例变量。</p>
<p>这个问题还有一种解决方法，就是尽量不要直接访问实例变量，应该通过存取方法来做。Objective-C 这门语言就是根据名称自动创建出存取方法，也就是 @property 语法。</p>
<h3 id="属性特质"><a href="#属性特质" class="headerlink" title="属性特质"></a>属性特质</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>所有属性都声明为 nonatomic 是因为：在 iOS 中使用同步锁开销较大，一般不要求属性必须是原子的，因为这并不能保证线程安全，若要实现线程安全，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写改值，那么即便将属性声明为 atomic 也还是会读到不同的属性值。</p>
<h4 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h4><p>readwrite / readonly</p>
<h4 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h4><ul>
<li><p>assign：纯量类型（scalar type），简单赋值操作</p>
</li>
<li><p>strong：拥有关系（owning relationship），为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</p>
</li>
<li><p>weak：非拥有关系（nonowning relationship），为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，类似 assign</p>
</li>
<li><p>copy：拷贝（copy），当属性类型为 NSString* 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例，此类是 NSString 的子类，如果不拷贝字符串，那么设置完属性后，字符串的值就会在对象不知情的情况被修改</p>
</li>
</ul>
<h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>getter=<name> / setter=<name></name></name></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isOn) <span class="built_in">BOOL</span> on;</span><br></pre></td></tr></table></figure>
<h2 id="7-在对象内部读写是否使用实例变量"><a href="#7-在对象内部读写是否使用实例变量" class="headerlink" title="7. 在对象内部读写是否使用实例变量"></a>7. 在对象内部读写是否使用实例变量</h2><p>直接访问实例变量和通过属性访问区别如下：</p>
<ul>
<li><p>直接访问实例变量的速度更快，由于不经过 OC 的<code>方法派发</code>（method dispatch），编译器所生成的代码会直接访问保存对象实例变量的那块内存；</p>
</li>
<li><p>直接访问实例变量不会调用设置方法，比如在 ARC 下直接访问一个声明为 copy 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值；</p>
</li>
<li><p>直接访问实例变量不会触发 KVO 通知；</p>
</li>
<li><p>通过属性访问有助于排查与之相关的错误</p>
</li>
</ul>
<p>总结为：在对象内部读取数据时，直接通过实例变量来读；写入数据时，通过属性 set 方法来写。</p>
<h2 id="8-以类族模式隐藏实现细节"><a href="#8-以类族模式隐藏实现细节" class="headerlink" title="8. 以类族模式隐藏实现细节"></a>8. 以类族模式隐藏实现细节</h2><p><code>类族</code>（class cluster）是一种很有用的模式，可以隐藏<code>抽象基类</code>（abstract base class）背后的实现细节，例如 UIButton 的类方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIButton</span> *)buttonWithType:(<span class="built_in">UIButtonType</span>)type;</span><br></pre></td></tr></table></figure>
<p>该方法所返回的对象，其类型取决于传入的按钮类型，然而，不管返回什么类型的对象，他们都继承同一个基类：UIButton，这么做的意义是，UIButton 的使用者无须关心创建出来的按钮具体属于哪个子类，只需明白如何创建按钮，设置属性即可。</p>
<p>举一个例子，创建一个 MYPerson 抽象类，MYStudent、MYTeacher、MYWorker 每一个子类都继承 MYPerson</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MYPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, MYPersonType) &#123;</span><br><span class="line"></span><br><span class="line">    MYPersonTypeStudent,</span><br><span class="line">    MYPersonTypeTeacher,</span><br><span class="line">    MYPersonTypeWorker,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)personWithType:(MYPersonType)type;</span><br><span class="line">- (<span class="keyword">void</span>)introduceMyself;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MYPerson.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MYStudent.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MYTeacher.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MYWorker.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MYPerson</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)personWithType:(MYPersonType)type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> MYPersonTypeStudent:</span><br><span class="line">            <span class="keyword">return</span> [[MYStudent alloc] init];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MYPersonTypeTeacher:</span><br><span class="line">            <span class="keyword">return</span> [[MYTeacher alloc] init];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MYPersonTypeWorker:</span><br><span class="line">            <span class="keyword">return</span> [[MYWorker alloc] init];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)introduceMyself</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>方法调用，打印结果为 MYWorker</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MYPerson *person = [MYPerson personWithType:MYPersonTypeWorker];</span><br><span class="line">[person introduceMyself];</span><br></pre></td></tr></table></figure>
<h2 id="9-理解-objc-msgSend-的作用"><a href="#9-理解-objc-msgSend-的作用" class="headerlink" title="9. 理解 objc_msgSend 的作用"></a>9. 理解 objc_msgSend 的作用</h2><h3 id="9-1-基本消息传递"><a href="#9-1-基本消息传递" class="headerlink" title="9.1 基本消息传递"></a>9.1 基本消息传递</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure>
<p>上面所示方法中，someObject 叫做<code>接受者</code>（receiver），messageName 叫做<code>选择子</code>（selector），选择子和参数合起来称为<code>消息</code>（message）。编译器将其转换为一条 C 语言函数调用，所调函数乃是消息传递机制中的核心函数，叫做 <code>objc_msgSend</code>，其原型如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = objc_msgSend(someObject, <span class="keyword">@selector</span>(messageName:), parameter);</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSend</code> 函数依据<code>接受者</code>和<code>选择子</code>的类型来调用适当的方法，该方法需要在接受者所属的类中搜寻其<code>方法列表</code>（list of methods），如果能找到与选择子名称相符的方法，就跳至其实现代码。如果找不到，就沿着继承体系继续向上查找，找到合适的方法再跳转。如果最终还是找不到，那就执行<code>消息转发</code>（message forwarding）</p>
<p>这么说来，想调用一个方法似乎需要很多步骤，但是，<code>objc_msgSend</code> 会将匹配结果缓存在<code>快速映射表</code>（fast map）里面，每个类都有这样一块缓存，如果稍后还向该类发送与选择子相同的消息，那么执行起来就很快了。</p>
<h3 id="9-2-其他消息传递"><a href="#9-2-其他消息传递" class="headerlink" title="9.2 其他消息传递"></a>9.2 其他消息传递</h3><h4 id="objc-msgSend-stret"><a href="#objc-msgSend-stret" class="headerlink" title="objc_msgSend_stret"></a>objc_msgSend_stret</h4><p>如果待发送的消息要返回结构体，可交由此函数处理。只有当 CPU 的寄存器能够容纳得下消息返回类型时，这个函数才能处理。如果返回的结构体太大了，就由另一个函数执行派发，会通过分配在栈上的某个变量来处理消息所返回的结构体。</p>
<h4 id="objc-msgSend-fpret"><a href="#objc-msgSend-fpret" class="headerlink" title="objc_msgSend_fpret"></a>objc_msgSend_fpret</h4><p>如果消息返回的是浮点数，那么可交由此函数处理。通常所用的 objc_msgSend 在这种情况下并不适合，这个函数是为了处理 x86 等架构 CPU 中某些奇怪状况。</p>
<h4 id="objc-msgSendSuper"><a href="#objc-msgSendSuper" class="headerlink" title="objc_msgSendSuper"></a>objc_msgSendSuper</h4><p>如果要给超类发消息，例如 <code>[super message:parameter]</code>，那么就交由此函数处理。也有另外两个与 <code>objc_msgSend_stret</code> 和 <code>objc_msgSend_fpret</code> 等效的函数，用于处理发给 super 的相应消息。</p>
<h3 id="9-3-尾调用优化"><a href="#9-3-尾调用优化" class="headerlink" title="9.3 尾调用优化"></a>9.3 尾调用优化</h3><p>每个类里都有一张表格，其中的指针都会指向这个函数，而选择子的名称则是查表时所用的 key，<code>objc_msgSend</code> 等函数的原理是，通过这张表格来寻找应该执行的方法。</p>
<p>原型的样子和 <code>objc_msgSend</code> 函数很像，这是利用<code>尾调用优化</code>（tail-call optimization）技术（函数最后一项操作是调用另外一个函数），编译器会生成跳转至另一个函数所需的指令码，而且不会向调用堆栈中推入新的<code>栈帧</code>（frame stack）。这项优化对 <code>objc_msgSend</code> 非常关键，如果不这么做的话，每次调用 Objective-C 方法之前，都需要为调用 <code>objc_msgSend</code> 函数准备栈帧。此外，若不优化，还会过早的发生<code>栈溢出</code>（stack overflow）现象。</p>
<h2 id="10-理解消息转发机制"><a href="#10-理解消息转发机制" class="headerlink" title="10. 理解消息转发机制"></a>10. 理解消息转发机制</h2><p>在编译期间向类发送了其无法解读的消息并不会报错，因为在运行期可以继续向类中添加方法。当对象接收到无法解读的消息后，就会启动<code>消息转发</code>（message forwarding）机制。</p>
<p>消息转发分为两大阶段：</p>
<h4 id="动态方法解析（dynamic-method-resolution）"><a href="#动态方法解析（dynamic-method-resolution）" class="headerlink" title="动态方法解析（dynamic method resolution）"></a>动态方法解析（dynamic method resolution）</h4><p>征询接收者，所属的类，看是否能动态添加方法，以处理当前这个<code>未知的选择子</code>（unknown selector）</p>
<h4 id="完整的消息转发机制（full-forwarding-mechanism）"><a href="#完整的消息转发机制（full-forwarding-mechanism）" class="headerlink" title="完整的消息转发机制（full forwarding mechanism）"></a>完整的消息转发机制（full forwarding mechanism）</h4><p>首先，接受者看看有没有其他对象能处理这条消息，如果有，运行时会把消息转给那个对象，消息转发过程结束，一切正常。若没有<code>备援的接收者</code>（replacement receiver）则启动完整的消息转发机制，运行时会把与消息有关的全部细节封装到 <code>NSInvocation</code> 对象中，再给接受者最后一次机会，令其设法解决当前还未处理的这条消息。</p>
<h3 id="10-1-动态方法解析"><a href="#10-1-动态方法解析" class="headerlink" title="10.1 动态方法解析"></a>10.1 动态方法解析</h3><p>对象在收到无法解读的消息后，首先将调用其所属类的下列类方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)selector</span><br></pre></td></tr></table></figure>
<p>如果尚未实现的方法是类方法，那么会调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)selector</span><br></pre></td></tr></table></figure>
<p>该方法的参数就是那个未知的选择子，其返回值为 BOOL 类型，表示这个类是否能新增一个实例方法用以处理此选择子。</p>
<p>使用这种方法的前提是：相关方法的实现代码已经写好，只等着运行时动态插在类里面就可以了。</p>
<p>举个例子，调用 Person 的 fly 方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">    </span><br><span class="line">SEL sel = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"fly"</span>);</span><br><span class="line">[p performSelector:sel];</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selString isEqualToString:<span class="string">@"fly"</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)fly, <span class="string">"v@:"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> fly(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"抱歉，人是不能飞的"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="10-2-备援的接收者"><a href="#10-2-备援的接收者" class="headerlink" title="10.2 备援的接收者"></a>10.2 备援的接收者</h3><p>如果上一步没有找到自定义的方法实现，这一步中，运行时系统会问它，能不能把这条消息转给其他接收者来处理</p>
<p>在上例中，如果 <code>resolveInstanceMethod:</code> 没有方法实现，则通过 <code>forwardingTargetForSelector:</code> 方法指定其他类来实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Bird.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Bird *bird;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (Bird *)bird</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_bird) &#123;</span><br><span class="line">        _bird = [[Bird alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _bird;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *selString = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="keyword">if</span> ([selString isEqualToString:<span class="string">@"fly"</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.bird;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>不用在 Bird.h 中暴露方法名，在 Bird.m 中实现即可</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Bird.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Bird</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fly</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我能飞"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="10-3-完整的消息转发"><a href="#10-3-完整的消息转发" class="headerlink" title="10.3 完整的消息转发"></a>10.3 完整的消息转发</h3><p>如果转发算法已经来到这一步的话，则启用完整的消息转发机制。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Bird.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Bird *bird;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (Bird *)bird</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_bird) &#123;</span><br><span class="line">        _bird = [[Bird alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _bird;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([Bird instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">            signature = [Bird instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([Bird instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:<span class="keyword">self</span>.bird];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>接收者在每一步均有机会处理消息，步骤越往后，处理消息的代价就越大，最好能在第一步就处理完，这样的话，运行时就可以将此方法缓存取来了。若想在第三步里把消息转给备援的接收者，那还不如把转发操作提前到第二步。因为第三步只是修改了调用目标，这项改动放在第二步执行会更为简单，不然的话，还得创建并处理完整的 <code>NSInvocation</code></p>
<p><img src="/img/img026.jpg" alt="image026"></p>
<h2 id="11-自定义初始化方法"><a href="#11-自定义初始化方法" class="headerlink" title="11. 自定义初始化方法"></a>11. 自定义初始化方法</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"我的名字为：%@"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> reason:<span class="string">@"Person 类必须使用 initWithName: 方法初始化"</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="12-实现-description-方法"><a href="#12-实现-description-方法" class="headerlink" title="12. 实现 description 方法"></a>12. 实现 description 方法</h2><p>打印自定义的类结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person: 0x608000001530&gt;</span><br></pre></td></tr></table></figure>
<p>上面这种内容不太有用，所以我们应该在自己的类中覆写 description 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@ : %p&gt;, name = \"%@\" age = %lu"</span>, <span class="keyword">self</span>.class, <span class="keyword">self</span>, <span class="keyword">self</span>.name, <span class="keyword">self</span>.age];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>创建并打印自定义类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">p.name = <span class="string">@"mayan"</span>;</span><br><span class="line">p.age = <span class="number">26</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, p);</span><br></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person : <span class="number">0x600000025560</span>&gt;, name = <span class="string">"mayan"</span> age = <span class="number">26</span></span><br></pre></td></tr></table></figure>
<p>以前还需要覆写 <code>debugDescription</code> 方法才能在断点时自定义打印，现在仅仅设置好 <code>description</code> 就可以了</p>
<h2 id="13-理解-NSCopying-协议"><a href="#13-理解-NSCopying-协议" class="headerlink" title="13. 理解 NSCopying 协议"></a>13. 理解 NSCopying 协议</h2><p>对象的拷贝通常使用 <code>copy</code> 方法完成，如果想令自己的类支持拷贝操作，那么就要实现 NSCopying 协议</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone;</span><br></pre></td></tr></table></figure>
<p>为何会出现 NSZone 呢？因为以前开发中，会据此把内存分为不同的<code>区</code>（zone），而对象会创建在某个区里面。现在不用了，每个程序只有一个<code>默认区</code>（default zone），所以实现这个方法，不必担心 zone 参数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> () &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="built_in">NSInteger</span>)age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _name = [name <span class="keyword">copy</span>];</span><br><span class="line">        _age  = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] initWithName:_name andAge:_age];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="14-协议、委托、分类"><a href="#14-协议、委托、分类" class="headerlink" title="14. 协议、委托、分类"></a>14. 协议、委托、分类</h2><p>Objective-C 语言有一项特性叫做<code>协议</code>（protocol），它与 Java 的<code>接口</code>（interface）类似。定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其<code>委托对象</code>（delegate），而这另一个对象则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。</p>
<p>此模式可将数据和业务逻辑解耦，比方说，用户界面里有个显示数据所用的视图，那么，此视图只应包含显示数据所需的逻辑代码，而不应决定要显示何种数据以及数据之间如何交互问题。视图对象的属性中，可以包含负责数据与事件处理的对象。这两种对象分别称为<code>数据源</code>（data source）与<code>委托</code>（delegate）</p>
<p>利用<code>分类</code>（Category）机制，我们无须继承子类即可直接为当前类添加方法，而在其他语言中，需通过继承子类来实现。由于 Objective-C 运行时是高度动态的，所以才能支持这一特性。</p>
<h2 id="15-以自动释放池块降低内存峰值"><a href="#15-以自动释放池块降低内存峰值" class="headerlink" title="15. 以自动释放池块降低内存峰值"></a>15. 以自动释放池块降低内存峰值</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> doSomethingWithInt:i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示代码，如果 <code>doSomethingWithInt:</code> 方法要创建临时对象，那么这些对象很可能放在自动释放池里，比方说，它们可能是一些临时字符串。但是，即使这些对象在调用完方法之后就不再使用，但是它们依然处于存活状态。这样一来，在执行 for 循环时，应用程序所占内存量就会持续上涨，等所有临时对象都释放之后，内存用量又突然下降。</p>
<p>如果把循环内的代码包裹在自动释放池块中，那么在循环中自动释放的对象就会放在这个池，而不是线程的主池里面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> doSomethingWithInt:i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，应用程序在执行循环时的内存峰值就会降低，但是是否应该用池来优化效率，完全取决于具体的应用程序。首先得监控内存用量，判断其中有没有需要解决的问题，别着急优化。尽管自动释放池块的开销不大，但是毕竟还是有的，所以尽量不要建立额外的自动释放池。</p>
<h2 id="16-理解-block"><a href="#16-理解-block" class="headerlink" title="16. 理解 block"></a>16. 理解 block</h2><p>当前多线程编程的核心就是<code>块</code>（block）和<code>大中枢派发</code>（Grand Central Dispatch，GCD），block 是一种在 C、C++、OC 中使用的<code>词法闭包</code>（lexical closure）</p>
<p><img src="/img/img027.png" alt="image027"></p>
<ul>
<li>在存放 block 对象的内存区域中，首个变量是 isa，指向 Class 对象的指针；</li>
<li>最重要的就是 invoke 变量，这是个函数指针，指向 block 的实现代码；</li>
<li>descriptor 变量是指向结构体的指针，其中声明了 block 对象的总体大小，还声明了 copy 和 dispose 这两个辅助函数所对应的函数指针，辅助函数在拷贝和丢弃 block 对象时运行，其中会执行一些操作，比如，前者要保留捕获的对象，后者将之释放；</li>
<li>block 还会把它所捕获的所有变量都拷贝一份，这些拷贝放在 descriptor 变量后面，捕获了多少个变量，就要占据多少内存空间。拷贝的并不是对象本身，而是指向这些对象的指针变量，原因是执行 block 时，要从内存中把这些捕获到的变量读出来。</li>
</ul>
<h2 id="17-多用派发队列，少用同步锁"><a href="#17-多用派发队列，少用同步锁" class="headerlink" title="17. 多用派发队列，少用同步锁"></a>17. 多用派发队列，少用同步锁</h2><p>防止多线程因为执行同一份代码而出问题，通常使用锁来实现某种同步机制。</p>
<h3 id="17-1-普通锁"><a href="#17-1-普通锁" class="headerlink" title="17.1 普通锁"></a>17.1 普通锁</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法的缺点是，滥用同步锁会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行，如果在 self 对象上频繁加锁，那么程序可能要等另一段与此无关的代码执行完毕，才能继续执行当前代码。</p>
<p>另一个办法是直接使用 NSLock 对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line"></span><br><span class="line">[_lock lock];</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">[_lock unlock];</span><br></pre></td></tr></table></figure>
<p>也可以使用 NSRecursiveLock 这种<code>递归锁</code>（recursive lock），线程能够多次持有该锁，而不会出现死锁（deadlock）现象。</p>
<p>这两种方法都很好，但是也有其缺陷，比如在极端情况下，同步块会导致死锁，另外其效率也不高，而如果直接使用锁对象的话，一旦遇到死锁，就会非常麻烦。</p>
<h3 id="17-2-GCD-相关锁"><a href="#17-2-GCD-相关锁" class="headerlink" title="17.2 GCD 相关锁"></a>17.2 GCD 相关锁</h3><p>有种简单高效的方法可以代替同步块或锁对象，那就是使用<code>串行同步队列</code>（serial synchronization queue），将读取操作、写入操作都安排在同一个队列里，即可保证数据同步</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_queue = dispatch_queue_create(<span class="string">"syncQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *localName;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^&#123;</span><br><span class="line">        localName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> localName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个更优的方法是，使用栅栏块来实现属性的设置方法，对属性的读取操作可以并发执行，但是写入操作却必须单独执行了。测试一下性能，发现这种做法比使用串行队列要快。</p>
<p><img src="/img/img028.png" alt="image028"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *localName;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^&#123;</span><br><span class="line">        localName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> localName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async(_queue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="18-多用-GCD，少用-performSelector-方法"><a href="#18-多用-GCD，少用-performSelector-方法" class="headerlink" title="18. 多用 GCD，少用 performSelector 方法"></a>18. 多用 GCD，少用 performSelector 方法</h2><p>performSelector 编程方式极为灵活，经常可以简化复杂的代码，但是如果在 ARC 下编译代码，那么编译器会发出内存泄漏的警告。原因在于，编译器并不知道将要调用的方法名和选择子，所以没有办法运用 ARC  的内存管理规则来判定返回值是不是应该释放，所以 ARC 比较谨慎，就是不添加释放操作，然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</p>
<p>替代方案就是使用 block，而且 performSelector 系列方法所提供的线程功能，都可以通过在大中枢派发机制中使用 block 来实现，延后执行可以用 dispatch_after，多线程可以使用 dispatch_sync 和 dispatch_async</p>
<h2 id="19-GCD-和-NSOperationQueue-使用时机"><a href="#19-GCD-和-NSOperationQueue-使用时机" class="headerlink" title="19. GCD 和 NSOperationQueue 使用时机"></a>19. GCD 和 NSOperationQueue 使用时机</h2><p>GCD 并不总是最佳方案，有的时候采用对象所带来的开销微乎其微，使用完整对象所带来的好处反而大大超过其缺点。</p>
<h4 id="取消某个操作"><a href="#取消某个操作" class="headerlink" title="取消某个操作"></a>取消某个操作</h4><p>如果使用 NSOperationQueue 取消操作是很容易的。运行任务前，可以在 NSOperation 对象上调用 cancel 方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。如果是使用 GCD 队列，那就无法取消了。</p>
<h4 id="指定操作间的依赖关系"><a href="#指定操作间的依赖关系" class="headerlink" title="指定操作间的依赖关系"></a>指定操作间的依赖关系</h4><p>一个操作可以依赖其他多个操作，开发者能够指定操作之间的依赖体系，使特定的操作必须在另外一个操作顺利执行完毕后方可执行。</p>
<h4 id="通过键值观察机制监控-NSOperation-对象的属性"><a href="#通过键值观察机制监控-NSOperation-对象的属性" class="headerlink" title="通过键值观察机制监控 NSOperation 对象的属性"></a>通过键值观察机制监控 NSOperation 对象的属性</h4><p>NSOperation 对象有许多属性都适合通过 KVO 来监听，比如可以通过 isCancelled 属性来判断任务是否已经取消，又比如可以通过 isFinished 属性来判断任务是否已经完成。</p>
<h4 id="指定操作的优先级"><a href="#指定操作的优先级" class="headerlink" title="指定操作的优先级"></a>指定操作的优先级</h4><p>GCD 的队列确实有优先级，不过那是针对整个队列来说的，而不是针对每个块来说的。因此，在优先级这一点上，NSOperationQueue 所提供的功能要比 GCD 更为便利</p>
<h2 id="20-不要使用-dispatch-get-current-queue"><a href="#20-不要使用-dispatch-get-current-queue" class="headerlink" title="20. 不要使用 dispatch_get_current_queue"></a>20. 不要使用 dispatch_get_current_queue</h2><p>使用 GCD 时，经常需要判断当前代码正在哪个队列上执行，我们会想到下面这个函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_current_queue();</span><br></pre></td></tr></table></figure>
<p>然而这个方法从 iOS 6.0 就已经弃用了，因为用它检测当前队列是不是某个特定的队列，以此来避免执行同步派发时，可能遭遇死锁问题。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *name;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^&#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法的问题在于，get 方法可能会死锁，假如调用 get 方法的队列恰好是 _queue，那么 dispatch_sync 就一直不会返回，直到 block 执行完毕为止。可是，应该执行 block 的那个目标队列确是当前队列，而当前队列的 dispatch_sync 又一直堵塞着，它在等待目标队列把这个 block 执行完，这样一来，block 就永远没有机会执行了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueA = dispatch_queue_create(<span class="string">"queueA"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueB = dispatch_queue_create(<span class="string">"queueB"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_sync</span>(queueA, ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queueB, ^&#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queueA, ^&#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面这段代码执行到最内层的派发操作时，总会死锁。因为此操作是针对 queueA 队列的，所以必须等最外层的 dispatch_sync 执行完毕才行，而最外层的 dispatch_sync 要等最内层的 dispatch_sync 执行完，于是就死锁了。将上面方法进行修改：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueA = dispatch_queue_create(<span class="string">"queueA"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueB = dispatch_queue_create(<span class="string">"queueB"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_sync</span>(queueA, ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queueB, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (dispatch_get_current_queue() == queueA) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">dispatch_sync</span>(queueA, ^&#123;</span><br><span class="line">               <span class="comment">// do something</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然而这样做依然死锁，因为 dispatch_get_current_queue 返回的是当前队列，也就是 queueB，这样针对 queueA 的同步派发操作依然会执行，于是还是死锁了。</p>
<p>要解决这个问题，最好的办法就是利用 <code>dispatch_queue_set_specific</code> 和 <code>dispatch_get_specific</code> 给 queue 关联一个 context data，后面再利用这个标识获取到 context data，如果可以获取到说明当前上下文是在自己创建的 queue 中，如果不能获取到则表示当前是在其他队列上。XMPP 中有比较多的使用案例。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueA = dispatch_queue_create(<span class="string">"queueA"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueB = dispatch_queue_create(<span class="string">"queueB"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *queueSpecificKey = <span class="string">@"queueSpecificKey"</span>;</span><br><span class="line">dispatch_queue_set_specific(queueA, queueSpecificKey, &amp;queueSpecificKey, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queueA, ^&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (dispatch_get_specific(queueSpecificKey)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"queueA - 当前为 queueA 队列"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"queueA - 当前为其他队列"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queueB, ^&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (dispatch_get_specific(queueSpecificKey)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"queueB - 当前为 queueA 队列"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"queueB - 当前为其他队列"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="21-Foundation-和-CoreFoundation-无缝桥接"><a href="#21-Foundation-和-CoreFoundation-无缝桥接" class="headerlink" title="21. Foundation 和 CoreFoundation 无缝桥接"></a>21. Foundation 和 CoreFoundation 无缝桥接</h2><h3 id="21-1-三种桥式转换"><a href="#21-1-三种桥式转换" class="headerlink" title="21.1 三种桥式转换"></a>21.1 三种桥式转换</h3><h4 id="bridge"><a href="#bridge" class="headerlink" title="__bridge"></a>__bridge</h4><p>ARC 仍然具备这个 Objective-C 对象的所有权</p>
<h4 id="bridge-retained"><a href="#bridge-retained" class="headerlink" title="__bridge_retained"></a>__bridge_retained</h4><p>与 __bridge 相反，意味着 ARC 将交出对象的所有权，用完需要 CFRelease 手动释放内存</p>
<h4 id="bridge-transfer"><a href="#bridge-transfer" class="headerlink" title="__bridge_transfer"></a>__bridge_transfer</h4><p>CoreFoundation 反向转换成 Foundation 类，令 ARC 获得对象所有权</p>
<h3 id="21-2-分析-CFMutableDictionary"><a href="#21-2-分析-CFMutableDictionary" class="headerlink" title="21.2 分析 CFMutableDictionary"></a>21.2 分析 CFMutableDictionary</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableDictionaryRef</span> dic =</span><br><span class="line">        <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(),</span><br><span class="line">                                  <span class="number">0</span>,</span><br><span class="line">                                  &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">                                  &amp;kCFTypeDictionaryValueCallBacks);</span><br></pre></td></tr></table></figure>
<p>首个参数表示将要使用的<code>内存分配器</code>（allocator）,CoreFoundation 对象里的数据结构需要占用内存，而分配器负责分配及回收这些内存。通常传入 NULL，表示采用默认的分配器。</p>
<p>第二个参数定义了字典的初始大小。并不会限制字典的最大容量，只是向分配器提示了一开始应该分配多少内存。假如要创建的字典含有 10 个对象，那就向该参数传入 10</p>
<p>最后两个参数值定义了许多回调函数，用于指示字典中的 key 和 value 在遇到各种事件时应该执行何种操作，点击进入这两个参数头文件可以看到其结构体如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span> version;</span><br><span class="line">    <span class="built_in">CFDictionaryRetainCallBack</span> <span class="keyword">retain</span>;</span><br><span class="line">    <span class="built_in">CFDictionaryReleaseCallBack</span> release;</span><br><span class="line">    <span class="built_in">CFDictionaryCopyDescriptionCallBack</span>	copyDescription;</span><br><span class="line">    <span class="built_in">CFDictionaryEqualCallBack</span>	equal;</span><br><span class="line">    <span class="built_in">CFDictionaryHashCallBack</span> hash;</span><br><span class="line">&#125; <span class="built_in">CFDictionaryKeyCallBacks</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span> version;</span><br><span class="line">    <span class="built_in">CFDictionaryRetainCallBack</span> <span class="keyword">retain</span>;</span><br><span class="line">    <span class="built_in">CFDictionaryReleaseCallBack</span> release;</span><br><span class="line">    <span class="built_in">CFDictionaryCopyDescriptionCallBack</span>	copyDescription;</span><br><span class="line">    <span class="built_in">CFDictionaryEqualCallBack</span> equal;</span><br><span class="line">&#125; <span class="built_in">CFDictionaryValueCallBacks</span>;</span><br></pre></td></tr></table></figure>
<p>version 参数用于检测新版与旧版数据结构之间是否兼容，目前应设为 0。结构体中其他成员都是函数指针，它们定义了当各种事件发生时应该采用哪个函数来执行相关任务。比如字典中加入新的 key 和 value，那么就会调用第二个 retain 函数。</p>
<h2 id="22-构建缓存时选用-NSCache-而非-NSDictionary"><a href="#22-构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="22. 构建缓存时选用 NSCache 而非 NSDictionary"></a>22. 构建缓存时选用 NSCache 而非 NSDictionary</h2><p>NSCache 胜过 NSDictionary 之处在于：</p>
<ol>
<li>当系统资源将要耗尽时，它可以自动删减缓存，如果采用字典，需要自己实现在系统低内存时发送通知删除缓存；</li>
<li>NSCache 还会先行删减最久未使用的对象，如果使用  NSDictionary 自己实现，会十分复杂；</li>
<li>NSCache 并不会拷贝键，而是会保留它，用 NSDictionary 实现的话需要相当复杂的代码。NSCache 对象不拷贝键的原因是：键是由不支持拷贝的对象来充当的；</li>
<li>NSCache 是线程安全的，而 NSDictionary 不具备此优势。在开发者不编写加锁代码的前提下，多个线程便可以同时访问 NSCache。</li>
</ol>
<p>下面这段代码演示了缓存的用法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _cache = [<span class="built_in">NSCache</span> new];</span><br><span class="line">        _cache.countLimit = <span class="number">100</span>;  <span class="comment">// Cache a maximum of 100 URLs</span></span><br><span class="line">        _cache.totalCostLimit = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadDataForURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *cacheData = [_cache objectForKey:url];</span><br><span class="line">    <span class="keyword">if</span> (cacheData) &#123;</span><br><span class="line">        <span class="comment">// get data</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MYNetworkFetcher *fetcher = [[MYNetworkFetcher alloc] initWithURL:url];</span><br><span class="line">        [fetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data) &#123;</span><br><span class="line">            [_cache setObject:data forKey:url cost:data.length];</span><br><span class="line">            <span class="comment">// get data</span></span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有个类叫做 NSPurgeableData，和 NSCache 搭配起来使用，效果更好，此类是 NSMutableData 的子类，而且实现了 NSDiscardableContent 协议。当系统资源紧张时，可以把保存 NSPurgeableData 对象的那块内存释放掉。NSDiscardableContent 协议里定义了名为 <code>isContentDiscarded</code> 的方法，可以用来查询相关内存是否已经释放。如果需要访问某个 NSPurgeableData 对象，可以调用其 <code>beginContentAccess</code> 方法，告诉它现在还不能丢弃自己所占据的内存。用完之后，调用 <code>endContentAccess</code> 方法，告诉它在必要时可以丢弃自己所占据的内存了。如果将 NSPurgeableData 对象加入 NSCache，那么当该对象为系统所丢弃时，也会自动从缓存中移除，通过 NSCache 的 <code>evictsObjectsWithDiscardedContent</code> 属性，可以开启或关闭此功能。修改代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _cache = [<span class="built_in">NSCache</span> new];</span><br><span class="line">        _cache.countLimit = <span class="number">100</span>;  <span class="comment">// Cache a maximum of 100 URLs</span></span><br><span class="line">        _cache.totalCostLimit = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)downloadDataForURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="built_in">NSPurgeableData</span> *cacheData = [_cache objectForKey:url];</span><br><span class="line">    <span class="keyword">if</span> (cacheData) &#123;</span><br><span class="line">        [cacheData beginContentAccess];</span><br><span class="line">        <span class="comment">// get data</span></span><br><span class="line">        [cacheData endContentAccess];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MYNetworkFetcher *fetcher = [[MYNetworkFetcher alloc] initWithURL:url];</span><br><span class="line">        [fetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data) &#123;</span><br><span class="line">            <span class="built_in">NSPurgeableData</span> *purgeableData = [<span class="built_in">NSPurgeableData</span> dataWithData:data];</span><br><span class="line">            [_cache setObject:purgeableData forKey:url cost:purgeableData.length];</span><br><span class="line">            <span class="comment">// 创建好 NSPurgeableData 对象以后，其 purge 引用计数会多 1，所以无须再调用 beginContentAccess</span></span><br><span class="line">            <span class="comment">// 然而其后必须调用 endContentAccess，将多出来的这个 1 抵消掉</span></span><br><span class="line">            <span class="comment">// get data</span></span><br><span class="line">            [purgeableData endContentAccess];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p>2017-05-05  一次阅读</p>
<p>去年阅读了一少半，然后因为项目耽搁了，而且笔记没有记得很清楚，所以这次又从头开始看。这本书还是很经典的，介绍了很多细节性的问题，理论性也很强，没有浪费这么长时间。</p>
<p>2018-01-24  二次阅读</p>
<p>很多概念性的东西时间长不看就容易遗忘，再次阅读并重新整理了理论知识，获益匪浅。有些知识并不是心里有大概的想法就算掌握，必须形成书面文字或者思路清晰的说出来才是真正的掌握。</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/27/【读书笔记】《iOS 开发进阶（唐巧）》/" rel="next" title="【读书笔记】《iOS 开发进阶（唐巧）》">
                <i class="fa fa-chevron-left"></i> 【读书笔记】《iOS 开发进阶（唐巧）》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/22/【iOS】保持界面流畅的技巧/" rel="prev" title="【iOS】保持界面流畅的技巧">
                【iOS】保持界面流畅的技巧 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpeg"
                alt="mayan" />
            
              <p class="site-author-name" itemprop="name">mayan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/mayan29" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:18511560993@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-了解-Objective-C-语言"><span class="nav-text">1. 了解 Objective-C 语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-在类的头文件中尽量少引入其他头文件"><span class="nav-text">2. 在类的头文件中尽量少引入其他头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-多用字面量语法，少用与之等价的方法"><span class="nav-text">3.多用字面量语法，少用与之等价的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-多用类型常量，少用-define-预处理指令"><span class="nav-text">4.多用类型常量，少用 #define 预处理指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-用枚举表示状态、选项、状态码"><span class="nav-text">5. 用枚举表示状态、选项、状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-理解属性这一概念"><span class="nav-text">6. 理解属性这一概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性特质"><span class="nav-text">属性特质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性"><span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读写权限"><span class="nav-text">读写权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存管理语义"><span class="nav-text">内存管理语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法名"><span class="nav-text">方法名</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-在对象内部读写是否使用实例变量"><span class="nav-text">7. 在对象内部读写是否使用实例变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-以类族模式隐藏实现细节"><span class="nav-text">8. 以类族模式隐藏实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-理解-objc-msgSend-的作用"><span class="nav-text">9. 理解 objc_msgSend 的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-基本消息传递"><span class="nav-text">9.1 基本消息传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-其他消息传递"><span class="nav-text">9.2 其他消息传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-msgSend-stret"><span class="nav-text">objc_msgSend_stret</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-msgSend-fpret"><span class="nav-text">objc_msgSend_fpret</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-msgSendSuper"><span class="nav-text">objc_msgSendSuper</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-尾调用优化"><span class="nav-text">9.3 尾调用优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-理解消息转发机制"><span class="nav-text">10. 理解消息转发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态方法解析（dynamic-method-resolution）"><span class="nav-text">动态方法解析（dynamic method resolution）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完整的消息转发机制（full-forwarding-mechanism）"><span class="nav-text">完整的消息转发机制（full forwarding mechanism）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-动态方法解析"><span class="nav-text">10.1 动态方法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-备援的接收者"><span class="nav-text">10.2 备援的接收者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-完整的消息转发"><span class="nav-text">10.3 完整的消息转发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-自定义初始化方法"><span class="nav-text">11. 自定义初始化方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-实现-description-方法"><span class="nav-text">12. 实现 description 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-理解-NSCopying-协议"><span class="nav-text">13. 理解 NSCopying 协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-协议、委托、分类"><span class="nav-text">14. 协议、委托、分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-以自动释放池块降低内存峰值"><span class="nav-text">15. 以自动释放池块降低内存峰值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-理解-block"><span class="nav-text">16. 理解 block</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-多用派发队列，少用同步锁"><span class="nav-text">17. 多用派发队列，少用同步锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-1-普通锁"><span class="nav-text">17.1 普通锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2-GCD-相关锁"><span class="nav-text">17.2 GCD 相关锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-多用-GCD，少用-performSelector-方法"><span class="nav-text">18. 多用 GCD，少用 performSelector 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-GCD-和-NSOperationQueue-使用时机"><span class="nav-text">19. GCD 和 NSOperationQueue 使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#取消某个操作"><span class="nav-text">取消某个操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指定操作间的依赖关系"><span class="nav-text">指定操作间的依赖关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过键值观察机制监控-NSOperation-对象的属性"><span class="nav-text">通过键值观察机制监控 NSOperation 对象的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指定操作的优先级"><span class="nav-text">指定操作的优先级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-不要使用-dispatch-get-current-queue"><span class="nav-text">20. 不要使用 dispatch_get_current_queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-Foundation-和-CoreFoundation-无缝桥接"><span class="nav-text">21. Foundation 和 CoreFoundation 无缝桥接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1-三种桥式转换"><span class="nav-text">21.1 三种桥式转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bridge"><span class="nav-text">__bridge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bridge-retained"><span class="nav-text">__bridge_retained</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bridge-transfer"><span class="nav-text">__bridge_transfer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-2-分析-CFMutableDictionary"><span class="nav-text">21.2 分析 CFMutableDictionary</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-构建缓存时选用-NSCache-而非-NSDictionary"><span class="nav-text">22. 构建缓存时选用 NSCache 而非 NSDictionary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后记"><span class="nav-text">后记</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mayan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://mayan29.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/';
          this.page.identifier = '2017/05/05/【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》/';
          this.page.title = '【读书笔记】《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法》';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://mayan29.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
